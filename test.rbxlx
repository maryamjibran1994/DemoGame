<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <float name="Brightness">2</float>
      <bool name="GlobalShadows">true</bool>
      <bool name="Outlines">false</bool>
      <token name="Technology">1</token>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">GameConfig</string>
          <string name="Source"><![CDATA[local GameConfig = {}

-- Game Settings
GameConfig.GRAVITY_SPEED = 196.2 -- Roblox default gravity
GameConfig.GRAVITY_CHANGE_COOLDOWN = 0.5 -- Seconds between gravity changes
GameConfig.COIN_VALUE = 10 -- Points per coin
GameConfig.COIN_SPAWN_RATE = 3 -- Seconds between coin spawns
GameConfig.MAX_COINS_PER_MAP = 50

-- Player Settings
GameConfig.PLAYER_SPEED = 16
GameConfig.PLAYER_JUMP_POWER = 50
GameConfig.PLAYER_WALK_SPEED = 16
GameConfig.PLAYER_MAX_SLOPE_ANGLE = 89

-- UI Colors
GameConfig.COLORS = {
	PRIMARY = Color3.fromRGB(52, 152, 219),
	SECONDARY = Color3.fromRGB(41, 128, 185),
	ACCENT = Color3.fromRGB(230, 126, 34),
	SUCCESS = Color3.fromRGB(46, 204, 113),
	WARNING = Color3.fromRGB(241, 196, 15),
	DANGER = Color3.fromRGB(231, 76, 60),
	BACKGROUND = Color3.fromRGB(44, 62, 80),
	TEXT = Color3.fromRGB(236, 240, 241)
}

-- Maps Configuration
GameConfig.MAPS = {
	{
		name = "Tutorial",
		description = "Learn the basics of gravity shifting",
		difficulty = 1,
		unlocked = true,
		thumbnail = "rbxassetid://0",
		checkpoints = 3,
		coins = 15,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 100),
		platforms = {
			{
				position = Vector3.new(0, 5, 20),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(0, 15, 40),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "normal"
			},
			{
				position = Vector3.new(0, 25, 60),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(230, 126, 34),
				type = "normal"
			},
			{
				position = Vector3.new(0, 35, 80),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(0, 18, 40)},
			{position = Vector3.new(0, 28, 60)},
			{position = Vector3.new(0, 38, 80)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(0, 18, 40)},
			{position = Vector3.new(0, 28, 60)}
		},
		obstacles = {}
	},
	{
		name = "Sky High",
		description = "Navigate through floating platforms",
		difficulty = 2,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 5,
		coins = 25,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 50, 150),
		platforms = {
			{
				position = Vector3.new(0, 20, 30),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(52, 152, 219),
				type = "moving",
				speed = Vector3.new(0, 1, 0)
			},
			{
				position = Vector3.new(30, 35, 60),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(46, 204, 113),
				type = "normal"
			},
			{
				position = Vector3.new(-30, 50, 90),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(230, 126, 34),
				type = "normal"
			},
			{
				position = Vector3.new(0, 65, 120),
				size = Vector3.new(8, 2, 8),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 23, 30)},
			{position = Vector3.new(30, 38, 60)},
			{position = Vector3.new(-30, 53, 90)},
			{position = Vector3.new(0, 68, 120)}
		},
		checkpoints = {
			{position = Vector3.new(0, 23, 30)},
			{position = Vector3.new(30, 38, 60)},
			{position = Vector3.new(-30, 53, 90)},
			{position = Vector3.new(0, 68, 120)}
		},
		obstacles = {
			{
				position = Vector3.new(15, 25, 45),
				size = Vector3.new(5, 10, 5),
				color = Color3.fromRGB(231, 76, 60)
			}
		}
	},
	{
		name = "Maze Runner",
		description = "Complex maze with gravity puzzles",
		difficulty = 3,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 8,
		coins = 40,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 200),
		platforms = {
			{
				position = Vector3.new(0, 5, 20),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(25, 5, 45),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "normal"
			},
			{
				position = Vector3.new(-25, 5, 70),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(230, 126, 34),
				type = "normal"
			},
			{
				position = Vector3.new(0, 5, 95),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(25, 8, 45)},
			{position = Vector3.new(-25, 8, 70)},
			{position = Vector3.new(0, 8, 95)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(25, 8, 45)},
			{position = Vector3.new(-25, 8, 70)},
			{position = Vector3.new(0, 8, 95)}
		},
		obstacles = {
			{
				position = Vector3.new(10, 5, 35),
				size = Vector3.new(3, 8, 3),
				color = Color3.fromRGB(231, 76, 60)
			},
			{
				position = Vector3.new(-10, 5, 35),
				size = Vector3.new(3, 8, 3),
				color = Color3.fromRGB(231, 76, 60)
			}
		}
	},
	{
		name = "Speed Demon",
		description = "Fast-paced gravity challenges",
		difficulty = 4,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 10,
		coins = 50,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 300),
		platforms = {
			{
				position = Vector3.new(0, 5, 25),
				size = Vector3.new(18, 2, 18),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(0, 15, 50),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "bounce",
				bouncePower = 80
			},
			{
				position = Vector3.new(0, 25, 75),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(230, 126, 34),
				type = "breakable"
			},
			{
				position = Vector3.new(0, 35, 100),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 25)},
			{position = Vector3.new(0, 18, 50)},
			{position = Vector3.new(0, 28, 75)},
			{position = Vector3.new(0, 38, 100)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 25)},
			{position = Vector3.new(0, 18, 50)},
			{position = Vector3.new(0, 28, 75)},
			{position = Vector3.new(0, 38, 100)}
		},
		obstacles = {
			{
				position = Vector3.new(0, 10, 40),
				size = Vector3.new(5, 5, 5),
				color = Color3.fromRGB(231, 76, 60)
			}
		}
	},
	{
		name = "Master's Challenge",
		description = "Ultimate gravity mastery test",
		difficulty = 5,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 15,
		coins = 100,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 500),
		platforms = {
			{
				position = Vector3.new(0, 5, 30),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(0, 20, 60),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "moving",
				speed = Vector3.new(0, 2, 0)
			},
			{
				position = Vector3.new(0, 40, 90),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(230, 126, 34),
				type = "breakable"
			},
			{
				position = Vector3.new(0, 60, 120),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(155, 89, 182),
				type = "bounce",
				bouncePower = 100
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 30)},
			{position = Vector3.new(0, 23, 60)},
			{position = Vector3.new(0, 43, 90)},
			{position = Vector3.new(0, 63, 120)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 30)},
			{position = Vector3.new(0, 23, 60)},
			{position = Vector3.new(0, 43, 90)},
			{position = Vector3.new(0, 63, 120)}
		},
		obstacles = {
			{
				position = Vector3.new(0, 15, 45),
				size = Vector3.new(8, 8, 8),
				color = Color3.fromRGB(231, 76, 60)
			},
			{
				position = Vector3.new(0, 35, 75),
				size = Vector3.new(6, 6, 6),
				color = Color3.fromRGB(241, 196, 15)
			}
		}
	}
}

-- Shop Items
GameConfig.SHOP_ITEMS = {
	{
		id = "speed_boost",
		name = "Speed Boost",
		description = "Increase movement speed by 25%",
		price = 100,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "jump_boost",
		name = "Jump Boost", 
		description = "Increase jump power by 30%",
		price = 150,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "gravity_master",
		name = "Gravity Master",
		description = "Reduce gravity change cooldown",
		price = 200,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "coin_magnet",
		name = "Coin Magnet",
		description = "Automatically collect nearby coins",
		price = 300,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "premium_skin",
		name = "Neon Character",
		description = "Exclusive neon character skin",
		price = 50,
		currency = "robux",
		type = "cosmetic"
	},
	{
		id = "vip_pass",
		name = "VIP Pass",
		description = "Access to exclusive maps and features",
		price = 100,
		currency = "robux",
		type = "cosmetic"
	}
}

-- Power-up Effects
GameConfig.POWERUP_EFFECTS = {
	speed_boost = {
		duration = 30,
		speed_multiplier = 1.25
	},
	jump_boost = {
		duration = 30,
		jump_multiplier = 1.3
	},
	gravity_master = {
		duration = 60,
		cooldown_reduction = 0.3
	},
	coin_magnet = {
		duration = 45,
		range = 20
	}
}

return GameConfig ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">Hello</string>
          <string name="Source">return function()
	print("Hello, world!")
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">MapGenerator</string>
          <string name="Source"><![CDATA[local MapGenerator = {}

-- Wait for GameConfig to be available
local GameConfig = require(script.Parent:WaitForChild("GameConfig", 10))

-- Platform types
local PLATFORM_TYPES = {
	BASIC = "basic",
	MOVING = "moving",
	BREAKABLE = "breakable",
	BOUNCE = "bounce",
	ICE = "ice"
}

-- Generate a map based on difficulty
function MapGenerator.generateMap(difficulty, mapName)
	local map = {
		name = mapName,
		difficulty = difficulty,
		platforms = {},
		coins = {},
		checkpoints = {},
		obstacles = {},
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 0)
	}
	
	-- Generate based on map name
	if mapName == "Tutorial" then
		MapGenerator.generateTutorialMap(map)
	elseif mapName == "Sky High" then
		MapGenerator.generateSkyHighMap(map)
	elseif mapName == "Maze Runner" then
		MapGenerator.generateMazeRunnerMap(map)
	elseif mapName == "Speed Demon" then
		MapGenerator.generateSpeedDemonMap(map)
	elseif mapName == "Master's Challenge" then
		MapGenerator.generateMastersChallengeMap(map)
	end
	
	return map
end

-- Tutorial map - simple introduction
function MapGenerator.generateTutorialMap(map)
	-- Starting platform
	table.insert(map.platforms, {
		type = PLATFORM_TYPES.BASIC,
		position = Vector3.new(0, 0, 0),
		size = Vector3.new(20, 2, 20),
		color = Color3.fromRGB(52, 152, 219)
	})
	
	-- First gravity challenge
	table.insert(map.platforms, {
		type = PLATFORM_TYPES.BASIC,
		position = Vector3.new(30, 15, 0),
		size = Vector3.new(8, 2, 8),
		color = Color3.fromRGB(46, 204, 113)
	})
	
	table.insert(map.platforms, {
		type = PLATFORM_TYPES.BASIC,
		position = Vector3.new(50, -15, 0),
		size = Vector3.new(8, 2, 8),
		color = Color3.fromRGB(230, 126, 34)
	})
	
	-- Coins for guidance
	table.insert(map.coins, {
		position = Vector3.new(30, 18, 0),
		value = 10
	})
	
	table.insert(map.coins, {
		position = Vector3.new(50, -12, 0),
		value = 10
	})
	
	-- Checkpoints
	table.insert(map.checkpoints, {
		position = Vector3.new(30, 15, 0),
		index = 1
	})
	
	table.insert(map.checkpoints, {
		position = Vector3.new(50, -15, 0),
		index = 2
	})
	
	-- Finish platform
	map.finishPoint = Vector3.new(80, 0, 0)
	table.insert(map.platforms, {
		type = PLATFORM_TYPES.BASIC,
		position = Vector3.new(80, 0, 0),
		size = Vector3.new(15, 2, 15),
		color = Color3.fromRGB(155, 89, 182)
	})
end

-- Sky High map - floating platforms
function MapGenerator.generateSkyHighMap(map)
	local platformCount = 15 + map.difficulty * 3
	
	for i = 1, platformCount do
		local x = i * 20 + math.random(-5, 5)
		local y = math.random(-30, 30)
		local z = math.random(-10, 10)
		
		table.insert(map.platforms, {
			type = PLATFORM_TYPES.BASIC,
			position = Vector3.new(x, y, z),
			size = Vector3.new(6 + math.random(2, 4), 2, 6 + math.random(2, 4)),
			color = Color3.fromRGB(
				math.random(100, 200),
				math.random(100, 200),
				math.random(100, 200)
			)
		})
		
		-- Add coins on some platforms
		if math.random() < 0.7 then
			table.insert(map.coins, {
				position = Vector3.new(x, y + 3, z),
				value = 10
			})
		end
	end
	
	-- Add checkpoints
	for i = 1, 5 do
		local checkpointIndex = math.floor(platformCount * i / 5)
		if map.platforms[checkpointIndex] then
			table.insert(map.checkpoints, {
				position = map.platforms[checkpointIndex].position,
				index = i
			})
		end
	end
	
	map.finishPoint = map.platforms[#map.platforms].position
end

-- Maze Runner map - complex layout
function MapGenerator.generateMazeRunnerMap(map)
	local mazeSize = 8
	local cellSize = 15
	
	-- Create maze grid
	for x = 1, mazeSize do
		for z = 1, mazeSize do
			local worldX = x * cellSize
			local worldZ = z * cellSize
			local worldY = math.random(-20, 20)
			
			-- Create platform with random height
			table.insert(map.platforms, {
				type = PLATFORM_TYPES.BASIC,
				position = Vector3.new(worldX, worldY, worldZ),
				size = Vector3.new(cellSize - 2, 2, cellSize - 2),
				color = Color3.fromRGB(52, 73, 94)
			})
			
			-- Add obstacles
			if math.random() < 0.3 then
				table.insert(map.obstacles, {
					type = "wall",
					position = Vector3.new(worldX, worldY + 5, worldZ),
					size = Vector3.new(2, 10, cellSize - 2),
					color = Color3.fromRGB(231, 76, 60)
				})
			end
			
			-- Add coins
			if math.random() < 0.6 then
				table.insert(map.coins, {
					position = Vector3.new(worldX, worldY + 3, worldZ),
					value = 15
				})
			end
		end
	end
	
	-- Add checkpoints at maze corners
	local checkpointPositions = {
		Vector3.new(cellSize * 2, 0, cellSize * 2),
		Vector3.new(cellSize * 4, 0, cellSize * 4),
		Vector3.new(cellSize * 6, 0, cellSize * 6)
	}
	
	for i, pos in ipairs(checkpointPositions) do
		table.insert(map.checkpoints, {
			position = pos,
			index = i
		})
	end
	
	map.finishPoint = Vector3.new(mazeSize * cellSize, 0, mazeSize * cellSize)
end

-- Speed Demon map - fast-paced challenges
function MapGenerator.generateSpeedDemonMap(map)
	local platformCount = 20
	
	for i = 1, platformCount do
		local x = i * 15
		local y = math.random(-25, 25)
		local z = math.random(-8, 8)
		
		local platformType = PLATFORM_TYPES.BASIC
		if math.random() < 0.3 then
			platformType = PLATFORM_TYPES.MOVING
		elseif math.random() < 0.2 then
			platformType = PLATFORM_TYPES.BREAKABLE
		end
		
		table.insert(map.platforms, {
			type = platformType,
			position = Vector3.new(x, y, z),
			size = Vector3.new(4, 2, 4),
			color = Color3.fromRGB(241, 196, 15),
			speed = platformType == PLATFORM_TYPES.MOVING and Vector3.new(0, 5, 0) or nil
		})
		
		-- Add coins between platforms
		if i < platformCount then
			table.insert(map.coins, {
				position = Vector3.new(x + 7, y + 5, z),
				value = 20
			})
		end
	end
	
	-- Add checkpoints
	for i = 1, 10 do
		local checkpointIndex = math.floor(platformCount * i / 10)
		if map.platforms[checkpointIndex] then
			table.insert(map.checkpoints, {
				position = map.platforms[checkpointIndex].position,
				index = i
			})
		end
	end
	
	map.finishPoint = map.platforms[#map.platforms].position
end

-- Master's Challenge map - ultimate test
function MapGenerator.generateMastersChallengeMap(map)
	local platformCount = 30
	
	for i = 1, platformCount do
		local x = i * 12
		local y = math.random(-40, 40)
		local z = math.random(-15, 15)
		
		-- Mix of all platform types
		local platformTypes = {PLATFORM_TYPES.BASIC, PLATFORM_TYPES.MOVING, PLATFORM_TYPES.BREAKABLE, PLATFORM_TYPES.BOUNCE}
		local platformType = platformTypes[math.random(1, #platformTypes)]
		
		table.insert(map.platforms, {
			type = platformType,
			position = Vector3.new(x, y, z),
			size = Vector3.new(3 + math.random(1, 3), 2, 3 + math.random(1, 3)),
			color = Color3.fromRGB(
				math.random(50, 255),
				math.random(50, 255),
				math.random(50, 255)
			),
			speed = platformType == PLATFORM_TYPES.MOVING and Vector3.new(0, 8, 0) or nil,
			bouncePower = platformType == PLATFORM_TYPES.BOUNCE and 50 or nil
		})
		
		-- Add coins with higher value
		if math.random() < 0.8 then
			table.insert(map.coins, {
				position = Vector3.new(x, y + 4, z),
				value = 25
			})
		end
		
		-- Add obstacles
		if math.random() < 0.4 then
			table.insert(map.obstacles, {
				type = "spike",
				position = Vector3.new(x, y + 2, z),
				size = Vector3.new(2, 4, 2),
				color = Color3.fromRGB(231, 76, 60)
			})
		end
	end
	
	-- Add checkpoints
	for i = 1, 15 do
		local checkpointIndex = math.floor(platformCount * i / 15)
		if map.platforms[checkpointIndex] then
			table.insert(map.checkpoints, {
				position = map.platforms[checkpointIndex].position,
				index = i
			})
		end
	end
	
	map.finishPoint = map.platforms[#map.platforms].position
end

return MapGenerator ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">PlayerData</string>
          <string name="Source"><![CDATA[local PlayerData = {}

-- Default player data structure
function PlayerData.new()
	return {
		coins = 0,
		robux = 0,
		level = 1,
		experience = 0,
		experienceToNext = 100,
		mapsCompleted = {},
		bestTimes = {},
		powerups = {},
		cosmetics = {},
		settings = {
			soundEnabled = true,
			musicEnabled = true,
			particleEffects = true
		},
		statistics = {
			totalPlayTime = 0,
			coinsCollected = 0,
			gravityShifts = 0,
			mapsPlayed = 0,
			deaths = 0
		}
	}
end

-- Calculate level from experience
function PlayerData.calculateLevel(experience)
	local level = 1
	local expNeeded = 100
	
	while experience >= expNeeded do
		experience = experience - expNeeded
		level = level + 1
		expNeeded = expNeeded * 1.2 -- 20% increase per level
	end
	
	return level, experience, expNeeded
end

-- Add experience and return level up info
function PlayerData.addExperience(playerData, amount)
	playerData.experience = playerData.experience + amount
	local newLevel, remainingExp, expNeeded = PlayerData.calculateLevel(playerData.experience)
	
	local leveledUp = newLevel > playerData.level
	if leveledUp then
		playerData.level = newLevel
		playerData.experience = remainingExp
		playerData.experienceToNext = expNeeded
	end
	
	return leveledUp, newLevel
end

-- Check if map is unlocked
function PlayerData.isMapUnlocked(playerData, mapIndex)
	if mapIndex == 1 then return true end -- Tutorial is always unlocked
	
	local requiredLevel = mapIndex * 2 -- Each map requires level 2, 4, 6, 8, 10
	return playerData.level >= requiredLevel
end

-- Get player's best time for a map
function PlayerData.getBestTime(playerData, mapName)
	return playerData.bestTimes[mapName] or math.huge
end

-- Update best time if better
function PlayerData.updateBestTime(playerData, mapName, time)
	local currentBest = PlayerData.getBestTime(playerData, mapName)
	if time < currentBest then
		playerData.bestTimes[mapName] = time
		return true -- New record
	end
	return false
end

-- Add coins with level up bonus
function PlayerData.addCoins(playerData, amount)
	local bonus = math.floor(playerData.level * 0.1 * amount) -- 10% bonus per level
	local total = amount + bonus
	playerData.coins = playerData.coins + total
	playerData.statistics.coinsCollected = playerData.statistics.coinsCollected + total
	return total, bonus
end

-- Check if player can afford item
function PlayerData.canAfford(playerData, price, currency)
	if currency == "coins" then
		return playerData.coins >= price
	elseif currency == "robux" then
		return playerData.robux >= price
	end
	return false
end

-- Purchase item
function PlayerData.purchaseItem(playerData, price, currency)
	if not PlayerData.canAfford(playerData, price, currency) then
		return false
	end
	
	if currency == "coins" then
		playerData.coins = playerData.coins - price
	elseif currency == "robux" then
		playerData.robux = playerData.robux - price
	end
	
	return true
end

-- Get player's powerup level
function PlayerData.getPowerupLevel(playerData, powerupId)
	return playerData.powerups[powerupId] or 0
end

-- Upgrade powerup
function PlayerData.upgradePowerup(playerData, powerupId)
	playerData.powerups[powerupId] = PlayerData.getPowerupLevel(playerData, powerupId) + 1
end

-- Get total play time in formatted string
function PlayerData.getFormattedPlayTime(playerData)
	local totalSeconds = playerData.statistics.totalPlayTime
	local hours = math.floor(totalSeconds / 3600)
	local minutes = math.floor((totalSeconds % 3600) / 60)
	local seconds = totalSeconds % 60
	
	if hours > 0 then
		return string.format("%dh %dm %ds", hours, minutes, seconds)
	elseif minutes > 0 then
		return string.format("%dm %ds", minutes, seconds)
	else
		return string.format("%ds", seconds)
	end
end

return PlayerData ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">TestModules</string>
          <string name="Source"><![CDATA[local TestModules = {}

-- Test function to verify all modules load correctly
function TestModules.testAllModules()
	local success = true
	local errors = {}
	
	-- Test GameConfig
	local success1, gameConfig = pcall(require, script.Parent.GameConfig)
	if not success1 then
		success = false
		table.insert(errors, "GameConfig: " .. tostring(gameConfig))
	else
		print("✓ GameConfig loaded successfully")
	end
	
	-- Test PlayerData
	local success2, playerData = pcall(require, script.Parent.PlayerData)
	if not success2 then
		success = false
		table.insert(errors, "PlayerData: " .. tostring(playerData))
	else
		print("✓ PlayerData loaded successfully")
	end
	
	-- Test MapGenerator
	local success3, mapGenerator = pcall(require, script.Parent.MapGenerator)
	if not success3 then
		success = false
		table.insert(errors, "MapGenerator: " .. tostring(mapGenerator))
	else
		print("✓ MapGenerator loaded successfully")
	end
	
	-- Test UISystem
	local success4, uiSystem = pcall(require, script.Parent.UISystem)
	if not success4 then
		success = false
		table.insert(errors, "UISystem: " .. tostring(uiSystem))
	else
		print("✓ UISystem loaded successfully")
	end
	
	if not success then
		print("❌ Module loading errors:")
		for _, error in ipairs(errors) do
			print("  - " .. error)
		end
	else
		print("✅ All modules loaded successfully!")
	end
	
	return success, errors
end

return TestModules ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">UISystem</string>
          <string name="Source"><![CDATA[local UISystem = {}

-- Wait for GameConfig to be available
local GameConfig = require(script.Parent:WaitForChild("GameConfig", 10))

-- UI Components
local function createFrame(parent, properties)
	local frame = Instance.new("Frame")
	for property, value in pairs(properties) do
		frame[property] = value
	end
	frame.Parent = parent
	return frame
end

local function createTextLabel(parent, properties)
	local label = Instance.new("TextLabel")
	for property, value in pairs(properties) do
		label[property] = value
	end
	label.Parent = parent
	return label
end

local function createTextButton(parent, properties)
	local button = Instance.new("TextButton")
	for property, value in pairs(properties) do
		button[property] = value
	end
	button.Parent = parent
	return button
end

local function createImageButton(parent, properties)
	local button = Instance.new("ImageButton")
	for property, value in pairs(properties) do
		button[property] = value
	end
	button.Parent = parent
	return button
end

local function createScrollingFrame(parent, properties)
	local frame = Instance.new("ScrollingFrame")
	for property, value in pairs(properties) do
		frame[property] = value
	end
	frame.Parent = parent
	return frame
end

-- Create main lobby UI
function UISystem.createLobbyUI()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "LobbyUI"
	screenGui.Parent = playerGui
	
	-- Background
	local background = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BackgroundTransparency = 0.1
	})
	
	-- Title
	local title = createTextLabel(background, {
		Size = UDim2.new(0, 400, 0, 80),
		Position = UDim2.new(0.5, -200, 0.1, 0),
		BackgroundTransparency = 1,
		Text = "GRAVITY SHIFT",
		TextColor3 = GameConfig.COLORS.PRIMARY,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	-- Player info panel
	local playerInfo = createFrame(background, {
		Size = UDim2.new(0, 300, 0, 150),
		Position = UDim2.new(0.05, 0, 0.1, 0),
		BackgroundColor3 = GameConfig.COLORS.SECONDARY,
		BorderSizePixel = 0
	})
	
	local playerName = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 30),
		Position = UDim2.new(0, 0, 0, 10),
		BackgroundTransparency = 1,
		Text = "Player",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	local playerLevel = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 25),
		Position = UDim2.new(0, 0, 0, 40),
		BackgroundTransparency = 1,
		Text = "Level: 1",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	local playerCoins = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 25),
		Position = UDim2.new(0, 0, 0, 65),
		BackgroundTransparency = 1,
		Text = "Coins: 0",
		TextColor3 = GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	local playerRobux = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 25),
		Position = UDim2.new(0, 0, 0, 90),
		BackgroundTransparency = 1,
		Text = "Robux: 0",
		TextColor3 = GameConfig.COLORS.SUCCESS,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	-- Map selection panel
	local mapPanel = createFrame(background, {
		Size = UDim2.new(0, 600, 0, 400),
		Position = UDim2.new(0.5, -300, 0.5, -200),
		BackgroundColor3 = GameConfig.COLORS.SECONDARY,
		BorderSizePixel = 0
	})
	
	local mapTitle = createTextLabel(mapPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Text = "Select Map",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local mapScroller = createScrollingFrame(mapPanel, {
		Size = UDim2.new(1, -20, 1, -60),
		Position = UDim2.new(0, 10, 0, 50),
		BackgroundTransparency = 1,
		ScrollBarThickness = 8,
		CanvasSize = UDim2.new(0, 0, 0, 0)
	})
	
	-- Buttons panel - moved to avoid overlap
	local buttonPanel = createFrame(background, {
		Size = UDim2.new(0, 400, 0, 200),
		Position = UDim2.new(0.05, 0, 0.7, 0),
		BackgroundTransparency = 1
	})
	
	local playButton = createTextButton(buttonPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.SUCCESS,
		Text = "PLAY",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local shopButton = createTextButton(buttonPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 60),
		BackgroundColor3 = GameConfig.COLORS.ACCENT,
		Text = "SHOP",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local settingsButton = createTextButton(buttonPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 120),
		BackgroundColor3 = GameConfig.COLORS.WARNING,
		Text = "SETTINGS",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		screenGui = screenGui,
		background = background,
		playerInfo = playerInfo,
		playerName = playerName,
		playerLevel = playerLevel,
		playerCoins = playerCoins,
		playerRobux = playerRobux,
		mapPanel = mapPanel,
		mapScroller = mapScroller,
		playButton = playButton,
		shopButton = shopButton,
		settingsButton = settingsButton
	}
end

-- Create shop UI
function UISystem.createShopUI()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ShopUI"
	screenGui.Parent = playerGui
	screenGui.Enabled = false
	
	-- Background
	local background = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.new(0, 0, 0),
		BackgroundTransparency = 0.3
	})
	
	-- Shop panel
	local shopPanel = createFrame(background, {
		Size = UDim2.new(0, 800, 0, 600),
		Position = UDim2.new(0.5, -400, 0.5, -300),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BorderSizePixel = 0
	})
	
	local shopTitle = createTextLabel(shopPanel, {
		Size = UDim2.new(1, 0, 0, 60),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		Text = "SHOP",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local closeButton = createTextButton(shopTitle, {
		Size = UDim2.new(0, 50, 1, 0),
		Position = UDim2.new(1, -50, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.DANGER,
		Text = "X",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local itemScroller = createScrollingFrame(shopPanel, {
		Size = UDim2.new(1, -20, 1, -80),
		Position = UDim2.new(0, 10, 0, 70),
		BackgroundTransparency = 1,
		ScrollBarThickness = 8,
		CanvasSize = UDim2.new(0, 0, 0, 0)
	})
	
	return {
		screenGui = screenGui,
		background = background,
		shopPanel = shopPanel,
		itemScroller = itemScroller,
		closeButton = closeButton
	}
end

-- Create in-game HUD
function UISystem.createGameHUD()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "GameHUD"
	screenGui.Parent = playerGui
	screenGui.Enabled = false
	
	-- Top bar
	local topBar = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 0, 60),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BorderSizePixel = 0
	})
	
	local timeLabel = createTextLabel(topBar, {
		Size = UDim2.new(0, 200, 1, 0),
		Position = UDim2.new(0, 10, 0, 0),
		BackgroundTransparency = 1,
		Text = "Time: 00:00",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local coinsLabel = createTextLabel(topBar, {
		Size = UDim2.new(0, 200, 1, 0),
		Position = UDim2.new(0.5, -100, 0, 0),
		BackgroundTransparency = 1,
		Text = "Coins: 0",
		TextColor3 = GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local checkpointLabel = createTextLabel(topBar, {
		Size = UDim2.new(0, 200, 1, 0),
		Position = UDim2.new(1, -210, 0, 0),
		BackgroundTransparency = 1,
		Text = "Checkpoint: 0/0",
		TextColor3 = GameConfig.COLORS.SUCCESS,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	-- Gravity indicator
	local gravityIndicator = createFrame(screenGui, {
		Size = UDim2.new(0, 100, 0, 100),
		Position = UDim2.new(1, -110, 0, 70),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		BorderSizePixel = 0
	})
	
	local gravityText = createTextLabel(gravityIndicator, {
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Text = "↓",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	-- Pause button
	local pauseButton = createTextButton(screenGui, {
		Size = UDim2.new(0, 50, 0, 50),
		Position = UDim2.new(0, 10, 0, 70),
		BackgroundColor3 = GameConfig.COLORS.WARNING,
		Text = "⏸",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		screenGui = screenGui,
		topBar = topBar,
		timeLabel = timeLabel,
		coinsLabel = coinsLabel,
		checkpointLabel = checkpointLabel,
		gravityIndicator = gravityIndicator,
		gravityText = gravityText,
		pauseButton = pauseButton
	}
end

-- Create pause menu
function UISystem.createPauseMenu()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "PauseMenu"
	screenGui.Parent = playerGui
	screenGui.Enabled = false
	
	-- Background
	local background = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.new(0, 0, 0),
		BackgroundTransparency = 0.5
	})
	
	-- Menu panel
	local menuPanel = createFrame(background, {
		Size = UDim2.new(0, 400, 0, 300),
		Position = UDim2.new(0.5, -200, 0.5, -150),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BorderSizePixel = 0
	})
	
	local menuTitle = createTextLabel(menuPanel, {
		Size = UDim2.new(1, 0, 0, 60),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		Text = "PAUSED",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local resumeButton = createTextButton(menuPanel, {
		Size = UDim2.new(0.8, 0, 0, 50),
		Position = UDim2.new(0.1, 0, 0.3, 0),
		BackgroundColor3 = GameConfig.COLORS.SUCCESS,
		Text = "RESUME",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local restartButton = createTextButton(menuPanel, {
		Size = UDim2.new(0.8, 0, 0, 50),
		Position = UDim2.new(0.1, 0, 0.5, 0),
		BackgroundColor3 = GameConfig.COLORS.WARNING,
		Text = "RESTART",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local quitButton = createTextButton(menuPanel, {
		Size = UDim2.new(0.8, 0, 0, 50),
		Position = UDim2.new(0.1, 0, 0.7, 0),
		BackgroundColor3 = GameConfig.COLORS.DANGER,
		Text = "QUIT TO LOBBY",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		screenGui = screenGui,
		background = background,
		menuPanel = menuPanel,
		resumeButton = resumeButton,
		restartButton = restartButton,
		quitButton = quitButton
	}
end

-- Create map selection item
function UISystem.createMapItem(parent, mapData, isUnlocked)
	local itemFrame = createFrame(parent, {
		Size = UDim2.new(1, -20, 0, 80),
		Position = UDim2.new(0, 10, 0, 0), -- Position will be set dynamically
		BackgroundColor3 = isUnlocked and GameConfig.COLORS.SECONDARY or Color3.fromRGB(100, 100, 100),
		BorderSizePixel = 0
	})
	
	local mapName = createTextLabel(itemFrame, {
		Size = UDim2.new(0.7, 0, 0.5, 0),
		Position = UDim2.new(0, 10, 0, 5),
		BackgroundTransparency = 1,
		Text = mapData.name,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local mapDesc = createTextLabel(itemFrame, {
		Size = UDim2.new(0.7, 0, 0.5, 0),
		Position = UDim2.new(0, 10, 0.5, 0),
		BackgroundTransparency = 1,
		Text = mapData.description,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local difficultyLabel = createTextLabel(itemFrame, {
		Size = UDim2.new(0.2, 0, 0.4, 0),
		Position = UDim2.new(0.75, 0, 0.1, 0),
		BackgroundTransparency = 1,
		Text = "★ " .. mapData.difficulty,
		TextColor3 = GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local selectButton = createTextButton(itemFrame, {
		Size = UDim2.new(0.2, 0, 0.4, 0),
		Position = UDim2.new(0.75, 0, 0.5, 0),
		BackgroundColor3 = isUnlocked and GameConfig.COLORS.SUCCESS or GameConfig.COLORS.DANGER,
		Text = isUnlocked and "PLAY" or "LOCKED",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		frame = itemFrame,
		name = mapName,
		description = mapDesc,
		difficulty = difficultyLabel,
		button = selectButton
	}
end

-- Create shop item
function UISystem.createShopItem(parent, itemData)
	local itemFrame = createFrame(parent, {
		Size = UDim2.new(1, -20, 0, 100),
		Position = UDim2.new(0, 10, 0, 0), -- Position will be set dynamically
		BackgroundColor3 = GameConfig.COLORS.SECONDARY,
		BorderSizePixel = 0
	})
	
	local itemName = createTextLabel(itemFrame, {
		Size = UDim2.new(0.6, 0, 0.4, 0),
		Position = UDim2.new(0, 10, 0, 5),
		BackgroundTransparency = 1,
		Text = itemData.name,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local itemDesc = createTextLabel(itemFrame, {
		Size = UDim2.new(0.6, 0, 0.4, 0),
		Position = UDim2.new(0, 10, 0.4, 0),
		BackgroundTransparency = 1,
		Text = itemData.description,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local priceLabel = createTextLabel(itemFrame, {
		Size = UDim2.new(0.3, 0, 0.4, 0),
		Position = UDim2.new(0.65, 0, 0.1, 0),
		BackgroundTransparency = 1,
		Text = itemData.price .. " " .. string.upper(itemData.currency),
		TextColor3 = itemData.currency == "robux" and GameConfig.COLORS.SUCCESS or GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local buyButton = createTextButton(itemFrame, {
		Size = UDim2.new(0.3, 0, 0.4, 0),
		Position = UDim2.new(0.65, 0, 0.5, 0),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		Text = "BUY",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		frame = itemFrame,
		name = itemName,
		description = itemDesc,
		price = priceLabel,
		button = buyButton
	}
end

return UISystem ]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="9">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="10">
      <Properties>
        <string name="Name">Server</string>
        <token name="RunContext">0</token>
        <string name="Source">-- Wait for ReplicatedStorage to be available
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- Wait for the Shared folder to be created by Rojo
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return
end

-- Test all shared modules first
local success = true
local errors = {}

-- Test GameConfig
local success1, result1 = pcall(require, Shared:WaitForChild("GameConfig", 10))
if not success1 then
	table.insert(errors, "GameConfig: " .. tostring(result1))
	success = false
end

-- Test PlayerData
local success2, result2 = pcall(require, Shared:WaitForChild("PlayerData", 10))
if not success2 then
	table.insert(errors, "PlayerData: " .. tostring(result2))
	success = false
end

-- Test UISystem
local success3, result3 = pcall(require, Shared:WaitForChild("UISystem", 10))
if not success3 then
	table.insert(errors, "UISystem: " .. tostring(result3))
	success = false
end

if not success then
	warn("Failed to load some modules:")
	for _, error in ipairs(errors) do
		warn("  " .. error)
	end
	return
end

-- Wait for GameManager to be available in the Server folder
local ServerFolder = ServerScriptService:WaitForChild("Server", 10)
if not ServerFolder then
	warn("Server folder not found in ServerScriptService")
	return
end

local GameManager = require(ServerFolder:WaitForChild("GameManager", 10))

-- Initialize the game manager
-- This will set up all the remote events and handle player connections

print("Gravity Shift - Server initialized!")

-- Set up workspace properties
local workspace = game:GetService("Workspace")
workspace.Gravity = 196.2 -- Default Roblox gravity

-- Set up lighting for better visual experience
local lighting = game:GetService("Lighting")
lighting.Ambient = Color3.fromRGB(100, 100, 100)
lighting.Brightness = 2
lighting.Outlines = false

print("Gravity Shift - Server setup complete!")</string>
      </Properties>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">GameManager</string>
          <string name="Source"><![CDATA[local GameManager = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")

-- Wait for shared modules to be available
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return GameManager
end

local GameConfig = require(Shared:WaitForChild("GameConfig", 10))
local PlayerData = require(Shared:WaitForChild("PlayerData", 10))

-- Remote events
local RemoteEvents = Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RequestPlayerData = Instance.new("RemoteEvent")
RequestPlayerData.Name = "RequestPlayerData"
RequestPlayerData.Parent = RemoteEvents

local UpdatePlayerData = Instance.new("RemoteEvent")
UpdatePlayerData.Name = "UpdatePlayerData"
UpdatePlayerData.Parent = RemoteEvents

local StartGame = Instance.new("RemoteEvent")
StartGame.Name = "StartGame"
StartGame.Parent = RemoteEvents

local EndGame = Instance.new("RemoteEvent")
EndGame.Name = "EndGame"
EndGame.Parent = RemoteEvents

local PurchaseItem = Instance.new("RemoteEvent")
PurchaseItem.Name = "PurchaseItem"
PurchaseItem.Parent = RemoteEvents

local CollectCoin = Instance.new("RemoteEvent")
CollectCoin.Name = "CollectCoin"
CollectCoin.Parent = RemoteEvents

local UpdateGravity = Instance.new("RemoteEvent")
UpdateGravity.Name = "UpdateGravity"
UpdateGravity.Parent = RemoteEvents

-- Player data storage
local playerDataStore = DataStoreService:GetDataStore("GravityShiftPlayerData")
local playerData = {}

-- Game state
local gameState = {
	activeGames = {},
	playerSessions = {}
}

-- Initialize player data
local function initializePlayer(player)
	local userId = player.UserId
	local success, data = pcall(function()
		return playerDataStore:GetAsync(userId)
	end)
	
	if success and data then
		playerData[userId] = data
	else
		playerData[userId] = PlayerData.new()
	end
	
	-- Update player name
	playerData[userId].name = player.Name
	
	-- Send initial data to client
	UpdatePlayerData:FireClient(player, playerData[userId])
end

-- Save player data
local function savePlayerData(player)
	local userId = player.UserId
	if playerData[userId] then
		local success, err = pcall(function()
			playerDataStore:SetAsync(userId, playerData[userId])
		end)
		
		if not success then
			warn("Failed to save data for player " .. player.Name .. ": " .. tostring(err))
		end
	end
end

-- Handle player joining
Players.PlayerAdded:Connect(function(player)
	initializePlayer(player)
end)

-- Handle player leaving
Players.PlayerRemoving:Connect(function(player)
	savePlayerData(player)
	
	-- Clean up game session
	if gameState.playerSessions[player.UserId] then
		local session = gameState.playerSessions[player.UserId]
		if session.activeGame then
			gameState.activeGames[session.activeGame] = nil
		end
		gameState.playerSessions[player.UserId] = nil
	end
	
	-- Remove from player data
	playerData[player.UserId] = nil
end)

-- Handle player data requests
RequestPlayerData.OnServerEvent:Connect(function(player)
	UpdatePlayerData:FireClient(player, playerData[player.UserId])
end)

-- Handle game start requests
StartGame.OnServerEvent:Connect(function(player, mapIndex)
	print("Player", player.Name, "requested to start map", mapIndex)
	
	local userId = player.UserId
	local playerDataInstance = playerData[userId]
	
	if not playerDataInstance then
		print("No player data found for", player.Name)
		return
	end
	
	-- Check if map is unlocked
	if not PlayerData.isMapUnlocked(playerDataInstance, mapIndex) then
		print("Map", mapIndex, "is not unlocked for", player.Name)
		return
	end
	
	-- Get map data
	local mapData = GameConfig.MAPS[mapIndex]
	if not mapData then
		print("Invalid map index:", mapIndex)
		return
	end
	
	print("Starting game for", player.Name, "on map:", mapData.name)
	
	-- Create game session
	local gameId = userId .. "_" .. tick()
	local gameSession = {
		id = gameId,
		player = player,
		mapData = mapData,
		startTime = tick(),
		coinsCollected = 0,
		checkpointsReached = 0,
		gravityShifts = 0,
		isActive = true
	}
	
	gameState.activeGames[gameId] = gameSession
	gameState.playerSessions[userId] = {
		activeGame = gameId,
		playerData = playerDataInstance
	}
	
	-- Update statistics
	playerDataInstance.statistics.mapsPlayed = playerDataInstance.statistics.mapsPlayed + 1
	
	-- Send game data to client
	StartGame:FireClient(player, mapIndex, gameId)
	print("Game started for", player.Name, "with game ID:", gameId)
end)

-- Handle game end
EndGame.OnServerEvent:Connect(function(player, gameId, completionData)
	local userId = player.UserId
	local gameSession = gameState.activeGames[gameId]
	local playerDataInstance = playerData[userId]
	
	if not gameSession or not playerDataInstance then
		return
	end
	
	-- Calculate rewards
	local timeBonus = math.max(0, 100 - completionData.time) * 10
	local coinBonus = completionData.coins * GameConfig.COIN_VALUE
	local totalReward = timeBonus + coinBonus
	
	-- Add coins and experience
	local coinsEarned, levelBonus = PlayerData.addCoins(playerDataInstance, totalReward)
	local leveledUp, newLevel = PlayerData.addExperience(playerDataInstance, completionData.time * 10)
	
	-- Update best time if better
	local newRecord = PlayerData.updateBestTime(playerDataInstance, gameSession.mapData.name, completionData.time)
	
	-- Update statistics
	playerDataInstance.statistics.totalPlayTime = playerDataInstance.statistics.totalPlayTime + completionData.time
	playerDataInstance.statistics.coinsCollected = playerDataInstance.statistics.coinsCollected + completionData.coins
	playerDataInstance.statistics.gravityShifts = playerDataInstance.statistics.gravityShifts + completionData.gravityShifts
	
	-- Mark map as completed
	playerDataInstance.mapsCompleted[gameSession.mapData.name] = true
	
	-- Clean up game session
	gameState.activeGames[gameId] = nil
	gameState.playerSessions[userId].activeGame = nil
	
	-- Send results to client
	EndGame:FireClient(player, {
		coinsEarned = coinsEarned,
		levelBonus = levelBonus,
		timeBonus = timeBonus,
		coinBonus = coinBonus,
		totalReward = totalReward,
		leveledUp = leveledUp,
		newLevel = newLevel,
		newRecord = newRecord,
		completionTime = completionData.time
	})
	
	-- Update client with new data
	UpdatePlayerData:FireClient(player, playerDataInstance)
end)

-- Handle coin collection
CollectCoin.OnServerEvent:Connect(function(player, gameId, coinId)
	local userId = player.UserId
	local gameSession = gameState.activeGames[gameId]
	
	if not gameSession or not gameSession.isActive then
		return
	end
	
	-- Find and remove coin
	for i, coin in ipairs(gameSession.mapData.coins) do
		if coin.id == coinId and not coin.collected then
			coin.collected = true
			gameSession.coinsCollected = gameSession.coinsCollected + coin.value
			break
		end
	end
end)

-- Handle gravity updates
UpdateGravity.OnServerEvent:Connect(function(player, gameId)
	local userId = player.UserId
	local gameSession = gameState.activeGames[gameId]
	
	if not gameSession or not gameSession.isActive then
		return
	end
	
	gameSession.gravityShifts = gameSession.gravityShifts + 1
end)

-- Handle item purchases
PurchaseItem.OnServerEvent:Connect(function(player, itemId)
	local userId = player.UserId
	local playerDataInstance = playerData[userId]
	
	if not playerDataInstance then
		return
	end
	
	-- Find item in shop
	local item = nil
	for _, shopItem in ipairs(GameConfig.SHOP_ITEMS) do
		if shopItem.id == itemId then
			item = shopItem
			break
		end
	end
	
	if not item then
		return
	end
	
	-- Check if player can afford
	if not PlayerData.canAfford(playerDataInstance, item.price, item.currency) then
		return
	end
	
	-- Process purchase
	if PlayerData.purchaseItem(playerDataInstance, item.price, item.currency) then
		-- Apply item effects
		if item.type == "powerup" then
			PlayerData.upgradePowerup(playerDataInstance, itemId)
		elseif item.type == "cosmetic" then
			playerDataInstance.cosmetics[itemId] = true
		end
		
		-- Update client
		UpdatePlayerData:FireClient(player, playerDataInstance)
	end
end)

-- Auto-save player data periodically
spawn(function()
	while true do
		wait(60) -- Save every minute
		for _, player in ipairs(Players:GetPlayers()) do
			savePlayerData(player)
		end
	end
end)

-- Get player data (for other scripts)
function GameManager.getPlayerData(player)
	return playerData[player.UserId]
end

-- Get active game session
function GameManager.getActiveGame(player)
	local userId = player.UserId
	local session = gameState.playerSessions[userId]
	if session and session.activeGame then
		return gameState.activeGames[session.activeGame]
	end
	return nil
end

return GameManager ]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="12">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="13">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="14">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="15">
        <Properties>
          <string name="Name">Client</string>
          <string name="Source">local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for the Shared folder to be created by Rojo
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return
end

-- Wait for GameController to be available in the Client folder
local player = Players.LocalPlayer
local ClientFolder = player:WaitForChild("PlayerScripts"):WaitForChild("Client", 10)
if not ClientFolder then
	warn("Client folder not found in PlayerScripts")
	return
end

local GameController = require(ClientFolder:WaitForChild("GameController", 10))

-- Check if GameController loaded successfully
if not GameController then
	warn("Failed to load GameController")
	return
end

-- Wait for character to load
local character = player.Character or player.CharacterAdded:Wait()

-- Initialize game when character is ready
character:WaitForChild("Humanoid")
character:WaitForChild("HumanoidRootPart")

-- Initialize the game
local success, err = pcall(GameController.init)
if not success then
	warn("Failed to initialize GameController:", err)
	return
end

-- Handle character respawning
player.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	character:WaitForChild("Humanoid")
	character:WaitForChild("HumanoidRootPart")
	
	-- Re-initialize game controller for new character
	local success, err = pcall(GameController.init)
	if not success then
		warn("Failed to re-initialize GameController:", err)
	end
end)

print("Gravity Shift - Client initialized!")</string>
        </Properties>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">GameController</string>
            <string name="Source"><![CDATA[local GameController = {}

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Wait for shared modules to be available
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return GameController
end

local GameConfig = nil
local PlayerData = nil
local UISystem = nil

-- Load shared modules with error handling
local success1, result1 = pcall(require, Shared:WaitForChild("GameConfig", 10))
if success1 then
	GameConfig = result1
else
	warn("Failed to load GameConfig:", result1)
	return GameController
end

local success2, result2 = pcall(require, Shared:WaitForChild("PlayerData", 10))
if success2 then
	PlayerData = result2
else
	warn("Failed to load PlayerData:", result2)
	return GameController
end

local success3, result3 = pcall(require, Shared:WaitForChild("UISystem", 10))
if success3 then
	UISystem = result3
else
	warn("Failed to load UISystem:", result3)
	return GameController
end

local player = Players.LocalPlayer
local character = nil
local humanoid = nil
local rootPart = nil

-- Function to setup character references
local function setupCharacterReferences()
	character = player.Character or player.CharacterAdded:Wait()
	humanoid = character:WaitForChild("Humanoid")
	rootPart = character:WaitForChild("HumanoidRootPart")
end

-- Game state (define early to prevent nil access)
local gameState = {
	isInGame = false,
	currentMap = nil,
	gameId = nil,
	startTime = 0,
	coinsCollected = 0,
	checkpointsReached = 0,
	gravityShifts = 0,
	currentGravity = Vector3.new(0, -196.2, 0), -- Default gravity, will be updated after GameConfig loads
	lastGravityChange = 0,
	canChangeGravity = true,
	activePowerups = {},
	gameObjects = {
		platforms = {},
		coins = {},
		checkpoints = {},
		obstacles = {}
	}
}

-- Update gravity with loaded config
if GameConfig then
	gameState.currentGravity = Vector3.new(0, -GameConfig.GRAVITY_SPEED, 0)
end

-- Remote events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
if not RemoteEvents then
	warn("RemoteEvents folder not found in ReplicatedStorage")
	return GameController
end

local RequestPlayerData = RemoteEvents:WaitForChild("RequestPlayerData", 10)
local UpdatePlayerData = RemoteEvents:WaitForChild("UpdatePlayerData", 10)
local StartGame = RemoteEvents:WaitForChild("StartGame", 10)
local EndGame = RemoteEvents:WaitForChild("EndGame", 10)
local PurchaseItem = RemoteEvents:WaitForChild("PurchaseItem", 10)
local CollectCoin = RemoteEvents:WaitForChild("CollectCoin", 10)
local UpdateGravity = RemoteEvents:WaitForChild("UpdateGravity", 10)

-- Check if all remote events loaded successfully
if not (RequestPlayerData and UpdatePlayerData and StartGame and EndGame and PurchaseItem and CollectCoin and UpdateGravity) then
	warn("Failed to load all remote events")
	return GameController
end



-- UI references
local lobbyUI = nil
local shopUI = nil
local gameHUD = nil
local pauseMenu = nil

-- Initialize game
function GameController.init()
	print("Initializing GameController...")
	
	-- Setup character references first
	setupCharacterReferences()
	
	-- Create UI
	print("Creating UI...")
	lobbyUI = UISystem.createLobbyUI()
	shopUI = UISystem.createShopUI()
	gameHUD = UISystem.createGameHUD()
	pauseMenu = UISystem.createPauseMenu()
	
	-- Request initial player data
	print("Requesting player data...")
	RequestPlayerData:FireServer()
	
	-- Setup UI connections
	print("Setting up UI connections...")
	setupUIConnections()
	
	-- Setup input handling
	print("Setting up input handling...")
	setupInputHandling()
	
	-- Setup remote event connections
	print("Setting up remote connections...")
	setupRemoteConnections()
	
	-- Show lobby
	print("Showing lobby...")
	showLobby()
	
	print("GameController initialization complete!")
end

-- Setup UI connections
function setupUIConnections()
	-- Lobby UI
	lobbyUI.shopButton.MouseButton1Click:Connect(function()
		showShop()
	end)
	
	lobbyUI.settingsButton.MouseButton1Click:Connect(function()
		-- TODO: Implement settings
		print("Settings not implemented yet")
	end)
	
	-- Connect the main PLAY button to start the first available map
	lobbyUI.playButton.MouseButton1Click:Connect(function()
		print("Play button clicked!")
		-- Find the first unlocked map
		for i, mapData in ipairs(GameConfig.MAPS) do
			if mapData.unlocked then
				print("Starting map:", i, mapData.name)
				StartGame:FireServer(i)
				break
			end
		end
	end)
	
	-- Shop UI
	shopUI.closeButton.MouseButton1Click:Connect(function()
		hideShop()
	end)
	
	-- Game HUD
	gameHUD.pauseButton.MouseButton1Click:Connect(function()
		showPauseMenu()
	end)
	
	-- Pause Menu
	pauseMenu.resumeButton.MouseButton1Click:Connect(function()
		hidePauseMenu()
	end)
	
	pauseMenu.restartButton.MouseButton1Click:Connect(function()
		restartGame()
	end)
	
	pauseMenu.quitButton.MouseButton1Click:Connect(function()
		quitToLobby()
	end)
end

-- Setup input handling
function setupInputHandling()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if gameState.isInGame then
			if input.KeyCode == Enum.KeyCode.Space then
				changeGravity()
			elseif input.KeyCode == Enum.KeyCode.R then
				restartGame()
			elseif input.KeyCode == Enum.KeyCode.Escape then
				showPauseMenu()
			end
		end
	end)
end

-- Setup remote event connections
function setupRemoteConnections()
	UpdatePlayerData.OnClientEvent:Connect(function(playerData)
		updatePlayerUI(playerData)
	end)
	
	StartGame.OnClientEvent:Connect(function(mapData, gameId)
		startGame(mapData, gameId)
	end)
	
	EndGame.OnClientEvent:Connect(function(results)
		endGame(results)
	end)
end

-- Show lobby
function showLobby()
	gameState.isInGame = false
	
	-- Hide other UI
	shopUI.screenGui.Enabled = false
	gameHUD.screenGui.Enabled = false
	pauseMenu.screenGui.Enabled = false
	
	-- Show lobby
	lobbyUI.screenGui.Enabled = true
	
	-- Populate map selection
	populateMapSelection()
	
	-- Reset character
	resetCharacter()
end

-- Show shop
function showShop()
	shopUI.screenGui.Enabled = true
	populateShop()
end

-- Hide shop
function hideShop()
	shopUI.screenGui.Enabled = false
end

-- Show pause menu
function showPauseMenu()
	pauseMenu.screenGui.Enabled = true
	RunService:SetRobloxGuiFocused(false)
end

-- Hide pause menu
function hidePauseMenu()
	pauseMenu.screenGui.Enabled = false
	RunService:SetRobloxGuiFocused(true)
end

-- Populate map selection
function populateMapSelection()
	-- Clear existing items
	for _, child in ipairs(lobbyUI.mapScroller:GetChildren()) do
		child:Destroy()
	end
	
	-- Add map items
	for i, mapData in ipairs(GameConfig.MAPS) do
		local mapItem = UISystem.createMapItem(lobbyUI.mapScroller, mapData, mapData.unlocked)
		
		-- Set proper position for the map item
		mapItem.frame.Position = UDim2.new(0, 0, 0, (i - 1) * 90)
		
		mapItem.button.MouseButton1Click:Connect(function()
			if mapData.unlocked then
				StartGame:FireServer(i)
			end
		end)
		
		-- Update canvas size
		lobbyUI.mapScroller.CanvasSize = UDim2.new(0, 0, 0, #GameConfig.MAPS * 90)
	end
end

-- Populate shop
function populateShop()
	-- Clear existing items
	for _, child in ipairs(shopUI.itemScroller:GetChildren()) do
		child:Destroy()
	end
	
	-- Add shop items
	for i, itemData in ipairs(GameConfig.SHOP_ITEMS) do
		local shopItem = UISystem.createShopItem(shopUI.itemScroller, itemData)
		
		-- Set proper position for the shop item
		shopItem.frame.Position = UDim2.new(0, 0, 0, (i - 1) * 110)
		
		shopItem.button.MouseButton1Click:Connect(function()
			PurchaseItem:FireServer(itemData.id)
		end)
		
		-- Update canvas size
		shopUI.itemScroller.CanvasSize = UDim2.new(0, 0, 0, #GameConfig.SHOP_ITEMS * 110)
	end
end

-- Update player UI
function updatePlayerUI(playerData)
	if not playerData then return end
	
	lobbyUI.playerName.Text = playerData.name or "Player"
	lobbyUI.playerLevel.Text = "Level: " .. playerData.level
	lobbyUI.playerCoins.Text = "Coins: " .. playerData.coins
	lobbyUI.playerRobux.Text = "Robux: " .. playerData.robux
	
	-- Update map unlock status
	for i, mapData in ipairs(GameConfig.MAPS) do
		mapData.unlocked = PlayerData.isMapUnlocked(playerData, i)
	end
end

-- Start game
function startGame(mapIndex, gameId)
	-- Get the actual map data from the index
	local mapData = GameConfig.MAPS[mapIndex]
	if not mapData then
		warn("Invalid map index:", mapIndex)
		return
	end
	
	gameState.isInGame = true
	gameState.currentMap = mapData
	gameState.gameId = gameId
	gameState.startTime = tick()
	gameState.coinsCollected = 0
	gameState.checkpointsReached = 0
	gameState.gravityShifts = 0
	
	-- Hide lobby and show game HUD
	lobbyUI.screenGui.Enabled = false
	gameHUD.screenGui.Enabled = true
	
	-- Build map
	buildMap(mapData)
	
	-- Setup character
	setupCharacter()
	
	-- Start game loop
	startGameLoop()
end

-- Build map
function buildMap(mapData)
	-- Clear existing objects
	clearGameObjects()
	
	-- Create platforms
	for i, platformData in ipairs(mapData.platforms) do
		local platform = Instance.new("Part")
		platform.Name = "Platform_" .. i
		platform.Position = platformData.position
		platform.Size = platformData.size
		platform.Color = platformData.color
		platform.Anchored = true
		platform.CanCollide = true
		platform.Material = Enum.Material.Plastic
		platform.Parent = Workspace
		
		table.insert(gameState.gameObjects.platforms, platform)
		
		-- Add platform behavior
		if platformData.type == "moving" and platformData.speed then
			setupMovingPlatform(platform, platformData.speed)
		elseif platformData.type == "breakable" then
			setupBreakablePlatform(platform)
		elseif platformData.type == "bounce" then
			setupBouncePlatform(platform, platformData.bouncePower or 50)
		end
	end
	
	-- Create coins
	for i, coinData in ipairs(mapData.coins) do
		local coin = Instance.new("Part")
		coin.Name = "Coin_" .. i
		coin.Position = coinData.position
		coin.Size = Vector3.new(2, 2, 2)
		coin.Color = Color3.fromRGB(255, 215, 0) -- Gold
		coin.Anchored = true
		coin.CanCollide = false
		coin.Shape = Enum.PartType.Ball
		coin.Material = Enum.Material.Neon
		coin.Parent = Workspace
		
		-- Add spinning animation
		local bodyGyro = Instance.new("BodyGyro")
		bodyGyro.MaxTorque = Vector3.new(0, 0, 0)
		bodyGyro.D = 0
		bodyGyro.P = 0
		bodyGyro.CFrame = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		bodyGyro.Parent = coin
		
		-- Add collection detection
		local touchInterest = Instance.new("TouchTransmitter")
		touchInterest.Parent = coin
		
		coin.Touched:Connect(function(hit)
			if character and hit.Parent == character then
				collectCoin(coin, i)
			end
		end)
		
		coinData.id = i
		table.insert(gameState.gameObjects.coins, coin)
	end
	
	-- Create checkpoints
	for i, checkpointData in ipairs(mapData.checkpoints) do
		local checkpoint = Instance.new("Part")
		checkpoint.Name = "Checkpoint_" .. i
		checkpoint.Position = checkpointData.position
		checkpoint.Size = Vector3.new(4, 8, 4)
		checkpoint.Color = Color3.fromRGB(46, 204, 113) -- Green
		checkpoint.Anchored = true
		checkpoint.CanCollide = false
		checkpoint.Transparency = 0.5
		checkpoint.Material = Enum.Material.Neon
		checkpoint.Parent = Workspace
		
		-- Add checkpoint detection
		checkpoint.Touched:Connect(function(hit)
			if character and hit.Parent == character then
				reachCheckpoint(i)
			end
		end)
		
		table.insert(gameState.gameObjects.checkpoints, checkpoint)
	end
	
	-- Create obstacles
	for i, obstacleData in ipairs(mapData.obstacles) do
		local obstacle = Instance.new("Part")
		obstacle.Name = "Obstacle_" .. i
		obstacle.Position = obstacleData.position
		obstacle.Size = obstacleData.size
		obstacle.Color = obstacleData.color
		obstacle.Anchored = true
		obstacle.CanCollide = true
		obstacle.Material = Enum.Material.Neon
		obstacle.Parent = Workspace
		
		table.insert(gameState.gameObjects.obstacles, obstacle)
	end
	
	-- Create finish point
	local finish = Instance.new("Part")
	finish.Name = "Finish"
	finish.Position = mapData.finishPoint
	finish.Size = Vector3.new(10, 2, 10)
	finish.Color = Color3.fromRGB(155, 89, 182) -- Purple
	finish.Anchored = true
	finish.CanCollide = true
	finish.Material = Enum.Material.Neon
	finish.Parent = Workspace
	
	finish.Touched:Connect(function(hit)
		if character and hit.Parent == character then
			completeGame()
		end
	end)
end

-- Clear game objects
function clearGameObjects()
	for _, objects in pairs(gameState.gameObjects) do
		for _, obj in ipairs(objects) do
			if obj and obj.Parent then
				obj:Destroy()
			end
		end
		objects = {}
	end
end

-- Setup character
function setupCharacter()
	if not character or not humanoid or not rootPart then
		setupCharacterReferences()
	end
	
	if character and humanoid and rootPart then
		-- Reset character position
		character:PivotTo(CFrame.new(gameState.currentMap.spawnPoint))
		
		-- Reset humanoid properties
		humanoid.WalkSpeed = GameConfig.PLAYER_WALK_SPEED
		humanoid.JumpPower = GameConfig.PLAYER_JUMP_POWER
		humanoid.MaxSlopeAngle = GameConfig.PLAYER_MAX_SLOPE_ANGLE
		
		-- Reset gravity
		gameState.currentGravity = Vector3.new(0, -GameConfig.GRAVITY_SPEED, 0)
		gameState.canChangeGravity = true
		gameState.lastGravityChange = 0
		
		-- Update gravity indicator
		updateGravityIndicator()
	end
end

-- Change gravity
function changeGravity()
	if not gameState.canChangeGravity then return end
	
	local currentTime = tick()
	if currentTime - gameState.lastGravityChange < GameConfig.GRAVITY_CHANGE_COOLDOWN then
		return
	end
	
	-- Cycle through gravity directions
	local gravityDirections = {
		Vector3.new(0, -GameConfig.GRAVITY_SPEED, 0),  -- Down
		Vector3.new(0, GameConfig.GRAVITY_SPEED, 0),   -- Up
		Vector3.new(-GameConfig.GRAVITY_SPEED, 0, 0),  -- Left
		Vector3.new(GameConfig.GRAVITY_SPEED, 0, 0),   -- Right
		Vector3.new(0, 0, -GameConfig.GRAVITY_SPEED),  -- Forward
		Vector3.new(0, 0, GameConfig.GRAVITY_SPEED)    -- Back
	}
	
	local currentIndex = 1
	for i, direction in ipairs(gravityDirections) do
		if direction == gameState.currentGravity then
			currentIndex = i
			break
		end
	end
	
	local nextIndex = (currentIndex % #gravityDirections) + 1
	gameState.currentGravity = gravityDirections[nextIndex]
	
	-- Update physics
	Workspace.Gravity = gameState.currentGravity.Y
	
	-- Update character orientation
	if rootPart then
		local lookDirection = gameState.currentGravity.Unit
		rootPart.CFrame = CFrame.lookAt(rootPart.Position, rootPart.Position + lookDirection)
	end
	
	-- Update UI
	updateGravityIndicator()
	
	-- Update server
	UpdateGravity:FireServer(gameState.gameId)
	
	-- Update cooldown
	gameState.lastGravityChange = currentTime
	gameState.gravityShifts = gameState.gravityShifts + 1
end

-- Update gravity indicator
function updateGravityIndicator()
	local gravityText = gameState.currentGravity
	local symbol = "↓"
	
	if gravityText.Y > 0 then
		symbol = "↑"
	elseif gravityText.X < 0 then
		symbol = "←"
	elseif gravityText.X > 0 then
		symbol = "→"
	elseif gravityText.Z < 0 then
		symbol = "↗"
	elseif gravityText.Z > 0 then
		symbol = "↙"
	end
	
	gameHUD.gravityText.Text = symbol
end

-- Collect coin
function collectCoin(coin, coinId)
	if not coin or not coin.Parent then return end
	
	-- Remove coin
	coin:Destroy()
	
	-- Update state
	gameState.coinsCollected = gameState.coinsCollected + 10
	
	-- Update UI
	gameHUD.coinsLabel.Text = "Coins: " .. gameState.coinsCollected
	
	-- Notify server
	CollectCoin:FireServer(gameState.gameId, coinId)
	
	-- Play collection effect
	playCoinEffect(coin.Position)
end

-- Reach checkpoint
function reachCheckpoint(checkpointIndex)
	if checkpointIndex > gameState.checkpointsReached then
		gameState.checkpointsReached = checkpointIndex
		gameHUD.checkpointLabel.Text = "Checkpoint: " .. gameState.checkpointsReached .. "/" .. #gameState.currentMap.checkpoints
		
		-- Play checkpoint effect
		playCheckpointEffect()
	end
end

-- Complete game
function completeGame()
	local completionTime = tick() - gameState.startTime
	
	local completionData = {
		time = completionTime,
		coins = gameState.coinsCollected,
		gravityShifts = gameState.gravityShifts
	}
	
	EndGame:FireServer(gameState.gameId, completionData)
end

-- End game
function endGame(results)
	gameState.isInGame = false
	
	-- Hide game HUD
	gameHUD.screenGui.Enabled = false
	
	-- Show results (TODO: Create results UI)
	print("Game completed!")
	print("Time: " .. string.format("%.2f", results.completionTime) .. "s")
	print("Coins: " .. results.coinsEarned)
	print("Total Reward: " .. results.totalReward)
	
	if results.leveledUp then
		print("Level Up! New level: " .. results.newLevel)
	end
	
	if results.newRecord then
		print("New Record!")
	end
	
	-- Return to lobby after delay
	wait(3)
	showLobby()
end

-- Restart game
function restartGame()
	if gameState.isInGame then
		StartGame:FireServer(1) -- Restart current map
	end
end

-- Quit to lobby
function quitToLobby()
	gameState.isInGame = false
	clearGameObjects()
	showLobby()
end

-- Start game loop
function startGameLoop()
	spawn(function()
		while gameState.isInGame do
			-- Update time display
			local currentTime = tick() - gameState.startTime
			local minutes = math.floor(currentTime / 60)
			local seconds = math.floor(currentTime % 60)
			gameHUD.timeLabel.Text = string.format("Time: %02d:%02d", minutes, seconds)
			
			wait(0.1)
		end
	end)
end

-- Platform behaviors
function setupMovingPlatform(platform, speed)
	spawn(function()
		local startPos = platform.Position
		local direction = 1
		
		while platform and platform.Parent do
			local newPos = startPos + Vector3.new(0, math.sin(tick() * speed.Y) * 10, 0)
			platform.Position = newPos
			wait(0.01)
		end
	end)
end

function setupBreakablePlatform(platform)
	platform.Touched:Connect(function(hit)
		if character and hit.Parent == character then
			wait(0.5)
			platform:Destroy()
		end
	end)
end

function setupBouncePlatform(platform, bouncePower)
	platform.Touched:Connect(function(hit)
		if character and hit.Parent == character and humanoid then
			humanoid.JumpPower = bouncePower
			wait(0.1)
			humanoid.JumpPower = GameConfig.PLAYER_JUMP_POWER
		end
	end)
end

-- Effects
function playCoinEffect(position)
	-- TODO: Add particle effects
end

function playCheckpointEffect()
	-- TODO: Add checkpoint effects
end

-- Reset character
function resetCharacter()
	if character and character.Parent then
		character:PivotTo(CFrame.new(0, 10, 0))
	end
end

-- Update character references when character respawns
player.CharacterAdded:Connect(function(newCharacter)
	setupCharacterReferences()
end)

return GameController ]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="17">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
    <Item class="Part" referent="18">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <Color3uint8 name="Color3uint8">6512483</Color3uint8>
        <bool name="Locked">true</bool>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-10</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>512</X>
          <Y>20</Y>
          <Z>512</Z>
        </Vector3>
      </Properties>
    </Item>
  </Item>
</roblox>
<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <float name="Brightness">2</float>
      <bool name="GlobalShadows">true</bool>
      <bool name="Outlines">false</bool>
      <token name="Technology">1</token>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">GameConfig</string>
          <string name="Source"><![CDATA[local GameConfig = {}

-- Game Settings
GameConfig.GRAVITY_SPEED = 196.2 -- Roblox default gravity
GameConfig.GRAVITY_CHANGE_COOLDOWN = 0.5 -- Seconds between gravity changes
GameConfig.COIN_VALUE = 10 -- Points per coin
GameConfig.COIN_SPAWN_RATE = 3 -- Seconds between coin spawns
GameConfig.MAX_COINS_PER_MAP = 50

-- Player Settings
GameConfig.PLAYER_SPEED = 16
GameConfig.PLAYER_JUMP_POWER = 50
GameConfig.PLAYER_WALK_SPEED = 16
GameConfig.PLAYER_MAX_SLOPE_ANGLE = 89

-- UI Colors
GameConfig.COLORS = {
	PRIMARY = Color3.fromRGB(52, 152, 219),
	SECONDARY = Color3.fromRGB(41, 128, 185),
	ACCENT = Color3.fromRGB(230, 126, 34),
	SUCCESS = Color3.fromRGB(46, 204, 113),
	WARNING = Color3.fromRGB(241, 196, 15),
	DANGER = Color3.fromRGB(231, 76, 60),
	BACKGROUND = Color3.fromRGB(44, 62, 80),
	TEXT = Color3.fromRGB(236, 240, 241)
}

-- Maps Configuration
GameConfig.MAPS = {
	{
		name = "Tutorial",
		description = "Learn the basics of gravity shifting",
		difficulty = 1,
		unlocked = true,
		thumbnail = "rbxassetid://0",
		checkpoints = 3,
		coins = 15,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 100),
		platforms = {
			{
				position = Vector3.new(0, 5, 20),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(0, 15, 40),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "normal"
			},
			{
				position = Vector3.new(0, 25, 60),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(230, 126, 34),
				type = "normal"
			},
			{
				position = Vector3.new(0, 35, 80),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(0, 18, 40)},
			{position = Vector3.new(0, 28, 60)},
			{position = Vector3.new(0, 38, 80)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(0, 18, 40)},
			{position = Vector3.new(0, 28, 60)}
		},
		obstacles = {}
	},
	{
		name = "Sky High",
		description = "Navigate through floating platforms",
		difficulty = 2,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 5,
		coins = 25,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 50, 150),
		platforms = {
			{
				position = Vector3.new(0, 20, 30),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(52, 152, 219),
				type = "moving",
				speed = Vector3.new(0, 1, 0)
			},
			{
				position = Vector3.new(30, 35, 60),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(46, 204, 113),
				type = "normal"
			},
			{
				position = Vector3.new(-30, 50, 90),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(230, 126, 34),
				type = "normal"
			},
			{
				position = Vector3.new(0, 65, 120),
				size = Vector3.new(8, 2, 8),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 23, 30)},
			{position = Vector3.new(30, 38, 60)},
			{position = Vector3.new(-30, 53, 90)},
			{position = Vector3.new(0, 68, 120)}
		},
		checkpoints = {
			{position = Vector3.new(0, 23, 30)},
			{position = Vector3.new(30, 38, 60)},
			{position = Vector3.new(-30, 53, 90)},
			{position = Vector3.new(0, 68, 120)}
		},
		obstacles = {
			{
				position = Vector3.new(15, 25, 45),
				size = Vector3.new(5, 10, 5),
				color = Color3.fromRGB(231, 76, 60)
			}
		}
	},
	{
		name = "Maze Runner",
		description = "Complex maze with gravity puzzles",
		difficulty = 3,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 8,
		coins = 40,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 200),
		platforms = {
			{
				position = Vector3.new(0, 5, 20),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(25, 5, 45),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "normal"
			},
			{
				position = Vector3.new(-25, 5, 70),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(230, 126, 34),
				type = "normal"
			},
			{
				position = Vector3.new(0, 5, 95),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(25, 8, 45)},
			{position = Vector3.new(-25, 8, 70)},
			{position = Vector3.new(0, 8, 95)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 20)},
			{position = Vector3.new(25, 8, 45)},
			{position = Vector3.new(-25, 8, 70)},
			{position = Vector3.new(0, 8, 95)}
		},
		obstacles = {
			{
				position = Vector3.new(10, 5, 35),
				size = Vector3.new(3, 8, 3),
				color = Color3.fromRGB(231, 76, 60)
			},
			{
				position = Vector3.new(-10, 5, 35),
				size = Vector3.new(3, 8, 3),
				color = Color3.fromRGB(231, 76, 60)
			}
		}
	},
	{
		name = "Speed Demon",
		description = "Fast-paced gravity challenges",
		difficulty = 4,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 10,
		coins = 50,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 300),
		platforms = {
			{
				position = Vector3.new(0, 5, 25),
				size = Vector3.new(18, 2, 18),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(0, 15, 50),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "bounce",
				bouncePower = 80
			},
			{
				position = Vector3.new(0, 25, 75),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(230, 126, 34),
				type = "breakable"
			},
			{
				position = Vector3.new(0, 35, 100),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(155, 89, 182),
				type = "normal"
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 25)},
			{position = Vector3.new(0, 18, 50)},
			{position = Vector3.new(0, 28, 75)},
			{position = Vector3.new(0, 38, 100)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 25)},
			{position = Vector3.new(0, 18, 50)},
			{position = Vector3.new(0, 28, 75)},
			{position = Vector3.new(0, 38, 100)}
		},
		obstacles = {
			{
				position = Vector3.new(0, 10, 40),
				size = Vector3.new(5, 5, 5),
				color = Color3.fromRGB(231, 76, 60)
			}
		}
	},
	{
		name = "Master's Challenge",
		description = "Ultimate gravity mastery test",
		difficulty = 5,
		unlocked = false,
		thumbnail = "rbxassetid://0",
		checkpoints = 15,
		coins = 100,
		spawnPoint = Vector3.new(0, 10, 0),
		finishPoint = Vector3.new(0, 10, 500),
		platforms = {
			{
				position = Vector3.new(0, 5, 30),
				size = Vector3.new(20, 2, 20),
				color = Color3.fromRGB(52, 152, 219),
				type = "normal"
			},
			{
				position = Vector3.new(0, 20, 60),
				size = Vector3.new(15, 2, 15),
				color = Color3.fromRGB(46, 204, 113),
				type = "moving",
				speed = Vector3.new(0, 2, 0)
			},
			{
				position = Vector3.new(0, 40, 90),
				size = Vector3.new(12, 2, 12),
				color = Color3.fromRGB(230, 126, 34),
				type = "breakable"
			},
			{
				position = Vector3.new(0, 60, 120),
				size = Vector3.new(10, 2, 10),
				color = Color3.fromRGB(155, 89, 182),
				type = "bounce",
				bouncePower = 100
			}
		},
		coins = {
			{position = Vector3.new(0, 8, 30)},
			{position = Vector3.new(0, 23, 60)},
			{position = Vector3.new(0, 43, 90)},
			{position = Vector3.new(0, 63, 120)}
		},
		checkpoints = {
			{position = Vector3.new(0, 8, 30)},
			{position = Vector3.new(0, 23, 60)},
			{position = Vector3.new(0, 43, 90)},
			{position = Vector3.new(0, 63, 120)}
		},
		obstacles = {
			{
				position = Vector3.new(0, 15, 45),
				size = Vector3.new(8, 8, 8),
				color = Color3.fromRGB(231, 76, 60)
			},
			{
				position = Vector3.new(0, 35, 75),
				size = Vector3.new(6, 6, 6),
				color = Color3.fromRGB(241, 196, 15)
			}
		}
	}
}

-- Shop Items
GameConfig.SHOP_ITEMS = {
	{
		id = "speed_boost",
		name = "Speed Boost",
		description = "Increase movement speed by 25%",
		price = 100,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "jump_boost",
		name = "Jump Boost", 
		description = "Increase jump power by 30%",
		price = 150,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "gravity_master",
		name = "Gravity Master",
		description = "Reduce gravity change cooldown",
		price = 200,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "coin_magnet",
		name = "Coin Magnet",
		description = "Automatically collect nearby coins",
		price = 300,
		currency = "coins",
		type = "powerup"
	},
	{
		id = "premium_skin",
		name = "Neon Character",
		description = "Exclusive neon character skin",
		price = 50,
		currency = "robux",
		type = "cosmetic"
	},
	{
		id = "vip_pass",
		name = "VIP Pass",
		description = "Access to exclusive maps and features",
		price = 100,
		currency = "robux",
		type = "cosmetic"
	}
}

-- Power-up Effects
GameConfig.POWERUP_EFFECTS = {
	speed_boost = {
		duration = 30,
		speed_multiplier = 1.25
	},
	jump_boost = {
		duration = 30,
		jump_multiplier = 1.3
	},
	gravity_master = {
		duration = 60,
		cooldown_reduction = 0.3
	},
	coin_magnet = {
		duration = 45,
		range = 20
	}
}

return GameConfig ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">Hello</string>
          <string name="Source">return function()
	print("Hello, world!")
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">PlayerData</string>
          <string name="Source"><![CDATA[local PlayerData = {}

-- Default player data structure
function PlayerData.new()
	return {
		coins = 0,
		robux = 0,
		level = 1,
		experience = 0,
		experienceToNext = 100,
		mapsCompleted = {},
		bestTimes = {},
		powerups = {},
		cosmetics = {},
		settings = {
			soundEnabled = true,
			musicEnabled = true,
			particleEffects = true
		},
		statistics = {
			totalPlayTime = 0,
			coinsCollected = 0,
			gravityShifts = 0,
			mapsPlayed = 0,
			deaths = 0
		}
	}
end

-- Calculate level from experience
function PlayerData.calculateLevel(experience)
	local level = 1
	local expNeeded = 100
	
	while experience >= expNeeded do
		experience = experience - expNeeded
		level = level + 1
		expNeeded = expNeeded * 1.2 -- 20% increase per level
	end
	
	return level, experience, expNeeded
end

-- Add experience and return level up info
function PlayerData.addExperience(playerData, amount)
	playerData.experience = playerData.experience + amount
	local newLevel, remainingExp, expNeeded = PlayerData.calculateLevel(playerData.experience)
	
	local leveledUp = newLevel > playerData.level
	if leveledUp then
		playerData.level = newLevel
		playerData.experience = remainingExp
		playerData.experienceToNext = expNeeded
	end
	
	return leveledUp, newLevel
end

-- Check if map is unlocked
function PlayerData.isMapUnlocked(playerData, mapIndex)
	if mapIndex == 1 then return true end -- Tutorial is always unlocked
	
	local requiredLevel = mapIndex * 2 -- Each map requires level 2, 4, 6, 8, 10
	return playerData.level >= requiredLevel
end

-- Get player's best time for a map
function PlayerData.getBestTime(playerData, mapName)
	return playerData.bestTimes[mapName] or math.huge
end

-- Update best time if better
function PlayerData.updateBestTime(playerData, mapName, time)
	local currentBest = PlayerData.getBestTime(playerData, mapName)
	if time < currentBest then
		playerData.bestTimes[mapName] = time
		return true -- New record
	end
	return false
end

-- Add coins with level up bonus
function PlayerData.addCoins(playerData, amount)
	local bonus = math.floor(playerData.level * 0.1 * amount) -- 10% bonus per level
	local total = amount + bonus
	playerData.coins = playerData.coins + total
	playerData.statistics.coinsCollected = playerData.statistics.coinsCollected + total
	return total, bonus
end

-- Check if player can afford item
function PlayerData.canAfford(playerData, price, currency)
	if currency == "coins" then
		return playerData.coins >= price
	elseif currency == "robux" then
		return playerData.robux >= price
	end
	return false
end

-- Purchase item
function PlayerData.purchaseItem(playerData, price, currency)
	if not PlayerData.canAfford(playerData, price, currency) then
		return false
	end
	
	if currency == "coins" then
		playerData.coins = playerData.coins - price
	elseif currency == "robux" then
		playerData.robux = playerData.robux - price
	end
	
	return true
end

-- Get player's powerup level
function PlayerData.getPowerupLevel(playerData, powerupId)
	return playerData.powerups[powerupId] or 0
end

-- Upgrade powerup
function PlayerData.upgradePowerup(playerData, powerupId)
	playerData.powerups[powerupId] = PlayerData.getPowerupLevel(playerData, powerupId) + 1
end

-- Get total play time in formatted string
function PlayerData.getFormattedPlayTime(playerData)
	local totalSeconds = playerData.statistics.totalPlayTime
	local hours = math.floor(totalSeconds / 3600)
	local minutes = math.floor((totalSeconds % 3600) / 60)
	local seconds = totalSeconds % 60
	
	if hours > 0 then
		return string.format("%dh %dm %ds", hours, minutes, seconds)
	elseif minutes > 0 then
		return string.format("%dm %ds", minutes, seconds)
	else
		return string.format("%ds", seconds)
	end
end

return PlayerData ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">UISystem</string>
          <string name="Source"><![CDATA[local UISystem = {}

-- Wait for GameConfig to be available
local GameConfig = require(script.Parent:WaitForChild("GameConfig", 10))

-- UI Components
local function createFrame(parent, properties)
	local frame = Instance.new("Frame")
	for property, value in pairs(properties) do
		frame[property] = value
	end
	frame.Parent = parent
	return frame
end

local function createTextLabel(parent, properties)
	local label = Instance.new("TextLabel")
	for property, value in pairs(properties) do
		label[property] = value
	end
	label.Parent = parent
	return label
end

local function createTextButton(parent, properties)
	local button = Instance.new("TextButton")
	for property, value in pairs(properties) do
		button[property] = value
	end
	button.Parent = parent
	return button
end

local function createImageButton(parent, properties)
	local button = Instance.new("ImageButton")
	for property, value in pairs(properties) do
		button[property] = value
	end
	button.Parent = parent
	return button
end

local function createScrollingFrame(parent, properties)
	local frame = Instance.new("ScrollingFrame")
	for property, value in pairs(properties) do
		frame[property] = value
	end
	frame.Parent = parent
	return frame
end

-- Create main lobby UI
function UISystem.createLobbyUI()
	print("Creating lobby UI...")
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "LobbyUI"
	screenGui.Parent = playerGui
	print("LobbyUI ScreenGui created")
	
	-- Background
	local background = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BackgroundTransparency = 0.1
	})
	
	-- Title
	local title = createTextLabel(background, {
		Size = UDim2.new(0, 400, 0, 80),
		Position = UDim2.new(0.5, -200, 0.1, 0),
		BackgroundTransparency = 1,
		Text = "GRAVITY SHIFT",
		TextColor3 = GameConfig.COLORS.PRIMARY,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	-- Player info panel
	local playerInfo = createFrame(background, {
		Size = UDim2.new(0, 300, 0, 150),
		Position = UDim2.new(0.05, 0, 0.1, 0),
		BackgroundColor3 = GameConfig.COLORS.SECONDARY,
		BorderSizePixel = 0
	})
	
	local playerName = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 30),
		Position = UDim2.new(0, 0, 0, 10),
		BackgroundTransparency = 1,
		Text = "Player",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	local playerLevel = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 25),
		Position = UDim2.new(0, 0, 0, 40),
		BackgroundTransparency = 1,
		Text = "Level: 1",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	local playerCoins = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 25),
		Position = UDim2.new(0, 0, 0, 65),
		BackgroundTransparency = 1,
		Text = "Coins: 0",
		TextColor3 = GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	local playerRobux = createTextLabel(playerInfo, {
		Size = UDim2.new(1, 0, 0, 25),
		Position = UDim2.new(0, 0, 0, 90),
		BackgroundTransparency = 1,
		Text = "Robux: 0",
		TextColor3 = GameConfig.COLORS.SUCCESS,
		TextScaled = true,
		Font = Enum.Font.Gotham
	})
	
	-- Map selection panel
	local mapPanel = createFrame(background, {
		Size = UDim2.new(0, 600, 0, 400),
		Position = UDim2.new(0.5, -300, 0.5, -200),
		BackgroundColor3 = GameConfig.COLORS.SECONDARY,
		BorderSizePixel = 0
	})
	
	local mapTitle = createTextLabel(mapPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Text = "Select Map",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local mapScroller = createScrollingFrame(mapPanel, {
		Size = UDim2.new(1, -20, 1, -60),
		Position = UDim2.new(0, 10, 0, 50),
		BackgroundTransparency = 1,
		ScrollBarThickness = 8,
		CanvasSize = UDim2.new(0, 0, 0, 0)
	})
	
	-- Buttons panel - moved to avoid overlap
	local buttonPanel = createFrame(background, {
		Size = UDim2.new(0, 400, 0, 200),
		Position = UDim2.new(0.05, 0, 0.7, 0),
		BackgroundTransparency = 1
	})
	
	local playButton = createTextButton(buttonPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.SUCCESS,
		Text = "PLAY",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	print("Play button created:", playButton.Name)
	
	local shopButton = createTextButton(buttonPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 60),
		BackgroundColor3 = GameConfig.COLORS.ACCENT,
		Text = "SHOP",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local settingsButton = createTextButton(buttonPanel, {
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 120),
		BackgroundColor3 = GameConfig.COLORS.WARNING,
		Text = "SETTINGS",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		screenGui = screenGui,
		background = background,
		playerInfo = playerInfo,
		playerName = playerName,
		playerLevel = playerLevel,
		playerCoins = playerCoins,
		playerRobux = playerRobux,
		mapPanel = mapPanel,
		mapScroller = mapScroller,
		playButton = playButton,
		shopButton = shopButton,
		settingsButton = settingsButton
	}
end

-- Create shop UI
function UISystem.createShopUI()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ShopUI"
	screenGui.Parent = playerGui
	screenGui.Enabled = false
	
	-- Background
	local background = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.new(0, 0, 0),
		BackgroundTransparency = 0.3
	})
	
	-- Shop panel
	local shopPanel = createFrame(background, {
		Size = UDim2.new(0, 800, 0, 600),
		Position = UDim2.new(0.5, -400, 0.5, -300),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BorderSizePixel = 0
	})
	
	local shopTitle = createTextLabel(shopPanel, {
		Size = UDim2.new(1, 0, 0, 60),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		Text = "SHOP",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local closeButton = createTextButton(shopTitle, {
		Size = UDim2.new(0, 50, 1, 0),
		Position = UDim2.new(1, -50, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.DANGER,
		Text = "X",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local itemScroller = createScrollingFrame(shopPanel, {
		Size = UDim2.new(1, -20, 1, -80),
		Position = UDim2.new(0, 10, 0, 70),
		BackgroundTransparency = 1,
		ScrollBarThickness = 8,
		CanvasSize = UDim2.new(0, 0, 0, 0)
	})
	
	return {
		screenGui = screenGui,
		background = background,
		shopPanel = shopPanel,
		itemScroller = itemScroller,
		closeButton = closeButton
	}
end

-- Create in-game HUD
function UISystem.createGameHUD()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "GameHUD"
	screenGui.Parent = playerGui
	screenGui.Enabled = false
	
	-- Top bar
	local topBar = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 0, 60),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BorderSizePixel = 0
	})
	
	local timeLabel = createTextLabel(topBar, {
		Size = UDim2.new(0, 200, 1, 0),
		Position = UDim2.new(0, 10, 0, 0),
		BackgroundTransparency = 1,
		Text = "Time: 00:00",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local coinsLabel = createTextLabel(topBar, {
		Size = UDim2.new(0, 200, 1, 0),
		Position = UDim2.new(0.5, -100, 0, 0),
		BackgroundTransparency = 1,
		Text = "Coins: 0",
		TextColor3 = GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local checkpointLabel = createTextLabel(topBar, {
		Size = UDim2.new(0, 200, 1, 0),
		Position = UDim2.new(1, -210, 0, 0),
		BackgroundTransparency = 1,
		Text = "Checkpoint: 0/0",
		TextColor3 = GameConfig.COLORS.SUCCESS,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	-- Gravity indicator
	local gravityIndicator = createFrame(screenGui, {
		Size = UDim2.new(0, 100, 0, 100),
		Position = UDim2.new(1, -110, 0, 70),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		BorderSizePixel = 0
	})
	
	local gravityText = createTextLabel(gravityIndicator, {
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Text = "↓",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	-- Pause button
	local pauseButton = createTextButton(screenGui, {
		Size = UDim2.new(0, 50, 0, 50),
		Position = UDim2.new(0, 10, 0, 70),
		BackgroundColor3 = GameConfig.COLORS.WARNING,
		Text = "⏸",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		screenGui = screenGui,
		topBar = topBar,
		timeLabel = timeLabel,
		coinsLabel = coinsLabel,
		checkpointLabel = checkpointLabel,
		gravityIndicator = gravityIndicator,
		gravityText = gravityText,
		pauseButton = pauseButton
	}
end

-- Create pause menu
function UISystem.createPauseMenu()
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "PauseMenu"
	screenGui.Parent = playerGui
	screenGui.Enabled = false
	
	-- Background
	local background = createFrame(screenGui, {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.new(0, 0, 0),
		BackgroundTransparency = 0.5
	})
	
	-- Menu panel
	local menuPanel = createFrame(background, {
		Size = UDim2.new(0, 400, 0, 300),
		Position = UDim2.new(0.5, -200, 0.5, -150),
		BackgroundColor3 = GameConfig.COLORS.BACKGROUND,
		BorderSizePixel = 0
	})
	
	local menuTitle = createTextLabel(menuPanel, {
		Size = UDim2.new(1, 0, 0, 60),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		Text = "PAUSED",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local resumeButton = createTextButton(menuPanel, {
		Size = UDim2.new(0.8, 0, 0, 50),
		Position = UDim2.new(0.1, 0, 0.3, 0),
		BackgroundColor3 = GameConfig.COLORS.SUCCESS,
		Text = "RESUME",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local restartButton = createTextButton(menuPanel, {
		Size = UDim2.new(0.8, 0, 0, 50),
		Position = UDim2.new(0.1, 0, 0.5, 0),
		BackgroundColor3 = GameConfig.COLORS.WARNING,
		Text = "RESTART",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	local quitButton = createTextButton(menuPanel, {
		Size = UDim2.new(0.8, 0, 0, 50),
		Position = UDim2.new(0.1, 0, 0.7, 0),
		BackgroundColor3 = GameConfig.COLORS.DANGER,
		Text = "QUIT TO LOBBY",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		screenGui = screenGui,
		background = background,
		menuPanel = menuPanel,
		resumeButton = resumeButton,
		restartButton = restartButton,
		quitButton = quitButton
	}
end

-- Create map selection item
function UISystem.createMapItem(parent, mapData, isUnlocked)
	local itemFrame = createFrame(parent, {
		Size = UDim2.new(1, -20, 0, 80),
		Position = UDim2.new(0, 10, 0, 0), -- Position will be set dynamically
		BackgroundColor3 = isUnlocked and GameConfig.COLORS.SECONDARY or Color3.fromRGB(100, 100, 100),
		BorderSizePixel = 0
	})
	
	local mapName = createTextLabel(itemFrame, {
		Size = UDim2.new(0.7, 0, 0.5, 0),
		Position = UDim2.new(0, 10, 0, 5),
		BackgroundTransparency = 1,
		Text = mapData.name,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local mapDesc = createTextLabel(itemFrame, {
		Size = UDim2.new(0.7, 0, 0.5, 0),
		Position = UDim2.new(0, 10, 0.5, 0),
		BackgroundTransparency = 1,
		Text = mapData.description,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local difficultyLabel = createTextLabel(itemFrame, {
		Size = UDim2.new(0.2, 0, 0.4, 0),
		Position = UDim2.new(0.75, 0, 0.1, 0),
		BackgroundTransparency = 1,
		Text = "★ " .. mapData.difficulty,
		TextColor3 = GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local selectButton = createTextButton(itemFrame, {
		Size = UDim2.new(0.2, 0, 0.4, 0),
		Position = UDim2.new(0.75, 0, 0.5, 0),
		BackgroundColor3 = isUnlocked and GameConfig.COLORS.SUCCESS or GameConfig.COLORS.DANGER,
		Text = isUnlocked and "PLAY" or "LOCKED",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		frame = itemFrame,
		name = mapName,
		description = mapDesc,
		difficulty = difficultyLabel,
		button = selectButton
	}
end

-- Create shop item
function UISystem.createShopItem(parent, itemData)
	local itemFrame = createFrame(parent, {
		Size = UDim2.new(1, -20, 0, 100),
		Position = UDim2.new(0, 10, 0, 0), -- Position will be set dynamically
		BackgroundColor3 = GameConfig.COLORS.SECONDARY,
		BorderSizePixel = 0
	})
	
	local itemName = createTextLabel(itemFrame, {
		Size = UDim2.new(0.6, 0, 0.4, 0),
		Position = UDim2.new(0, 10, 0, 5),
		BackgroundTransparency = 1,
		Text = itemData.name,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local itemDesc = createTextLabel(itemFrame, {
		Size = UDim2.new(0.6, 0, 0.4, 0),
		Position = UDim2.new(0, 10, 0.4, 0),
		BackgroundTransparency = 1,
		Text = itemData.description,
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.Gotham,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local priceLabel = createTextLabel(itemFrame, {
		Size = UDim2.new(0.3, 0, 0.4, 0),
		Position = UDim2.new(0.65, 0, 0.1, 0),
		BackgroundTransparency = 1,
		Text = itemData.price .. " " .. string.upper(itemData.currency),
		TextColor3 = itemData.currency == "robux" and GameConfig.COLORS.SUCCESS or GameConfig.COLORS.ACCENT,
		TextScaled = true,
		Font = Enum.Font.GothamBold
	})
	
	local buyButton = createTextButton(itemFrame, {
		Size = UDim2.new(0.3, 0, 0.4, 0),
		Position = UDim2.new(0.65, 0, 0.5, 0),
		BackgroundColor3 = GameConfig.COLORS.PRIMARY,
		Text = "BUY",
		TextColor3 = GameConfig.COLORS.TEXT,
		TextScaled = true,
		Font = Enum.Font.GothamBold,
		BorderSizePixel = 0
	})
	
	return {
		frame = itemFrame,
		name = itemName,
		description = itemDesc,
		price = priceLabel,
		button = buyButton
	}
end

return UISystem ]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="7">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="8">
      <Properties>
        <string name="Name">Server</string>
        <token name="RunContext">0</token>
        <string name="Source">-- Wait for ReplicatedStorage to be available
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- Wait for the Shared folder to be created by Rojo
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return
end

-- Test all shared modules first
local success = true
local errors = {}

-- Test GameConfig
local success1, result1 = pcall(require, Shared:WaitForChild("GameConfig", 10))
if not success1 then
	table.insert(errors, "GameConfig: " .. tostring(result1))
	success = false
end

-- Test PlayerData
local success2, result2 = pcall(require, Shared:WaitForChild("PlayerData", 10))
if not success2 then
	table.insert(errors, "PlayerData: " .. tostring(result2))
	success = false
end

-- Test UISystem
local success3, result3 = pcall(require, Shared:WaitForChild("UISystem", 10))
if not success3 then
	table.insert(errors, "UISystem: " .. tostring(result3))
	success = false
end

if not success then
	warn("Failed to load some modules:")
	for _, error in ipairs(errors) do
		warn("  " .. error)
	end
	return
end

-- Wait for GameManager to be available in the Server folder
local ServerFolder = ServerScriptService:WaitForChild("Server", 10)
if not ServerFolder then
	warn("Server folder not found in ServerScriptService")
	return
end

local GameManager = require(ServerFolder:WaitForChild("GameManager", 10))

-- Initialize the game manager
-- This will set up all the remote events and handle player connections

print("Gravity Shift - Server initialized!")

-- Set up workspace properties
local workspace = game:GetService("Workspace")
workspace.Gravity = 196.2 -- Default Roblox gravity

-- Set up lighting for better visual experience
local lighting = game:GetService("Lighting")
lighting.Ambient = Color3.fromRGB(100, 100, 100)
lighting.Brightness = 2
lighting.Outlines = false

print("Gravity Shift - Server setup complete!")</string>
      </Properties>
      <Item class="ModuleScript" referent="9">
        <Properties>
          <string name="Name">GameManager</string>
          <string name="Source"><![CDATA[local GameManager = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")

-- Wait for shared modules to be available
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return GameManager
end

local GameConfig = require(Shared:WaitForChild("GameConfig", 10))
local PlayerData = require(Shared:WaitForChild("PlayerData", 10))

-- Remote events
print("Creating remote events...")
local RemoteEvents = Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage
print("RemoteEvents folder created")

local RequestPlayerData = Instance.new("RemoteEvent")
RequestPlayerData.Name = "RequestPlayerData"
RequestPlayerData.Parent = RemoteEvents

local UpdatePlayerData = Instance.new("RemoteEvent")
UpdatePlayerData.Name = "UpdatePlayerData"
UpdatePlayerData.Parent = RemoteEvents

local StartGame = Instance.new("RemoteEvent")
StartGame.Name = "StartGame"
StartGame.Parent = RemoteEvents

local EndGame = Instance.new("RemoteEvent")
EndGame.Name = "EndGame"
EndGame.Parent = RemoteEvents

local PurchaseItem = Instance.new("RemoteEvent")
PurchaseItem.Name = "PurchaseItem"
PurchaseItem.Parent = RemoteEvents

local CollectCoin = Instance.new("RemoteEvent")
CollectCoin.Name = "CollectCoin"
CollectCoin.Parent = RemoteEvents

local UpdateGravity = Instance.new("RemoteEvent")
UpdateGravity.Name = "UpdateGravity"
UpdateGravity.Parent = RemoteEvents

print("All remote events created successfully")

-- Player data storage
local playerDataStore = DataStoreService:GetDataStore("GravityShiftPlayerData")
local playerData = {}

-- Game state
local gameState = {
	activeGames = {},
	playerSessions = {}
}

-- Initialize player data
local function initializePlayer(player)
	local userId = player.UserId
	local success, data = pcall(function()
		return playerDataStore:GetAsync(userId)
	end)
	
	if success and data then
		playerData[userId] = data
	else
		playerData[userId] = PlayerData.new()
	end
	
	-- Update player name
	playerData[userId].name = player.Name
	
	-- Send initial data to client
	UpdatePlayerData:FireClient(player, playerData[userId])
end

-- Save player data
local function savePlayerData(player)
	local userId = player.UserId
	if playerData[userId] then
		local success, err = pcall(function()
			playerDataStore:SetAsync(userId, playerData[userId])
		end)
		
		if not success then
			warn("Failed to save data for player " .. player.Name .. ": " .. tostring(err))
		end
	end
end

-- Handle player joining
Players.PlayerAdded:Connect(function(player)
	initializePlayer(player)
end)

-- Handle player leaving
Players.PlayerRemoving:Connect(function(player)
	savePlayerData(player)
	
	-- Clean up game session
	if gameState.playerSessions[player.UserId] then
		local session = gameState.playerSessions[player.UserId]
		if session.activeGame then
			gameState.activeGames[session.activeGame] = nil
		end
		gameState.playerSessions[player.UserId] = nil
	end
	
	-- Remove from player data
	playerData[player.UserId] = nil
end)

-- Handle player data requests
RequestPlayerData.OnServerEvent:Connect(function(player)
	UpdatePlayerData:FireClient(player, playerData[player.UserId])
end)

-- Handle game start requests
StartGame.OnServerEvent:Connect(function(player, mapIndex)
	print("Player", player.Name, "requested to start map", mapIndex)
	
	local userId = player.UserId
	local playerDataInstance = playerData[userId]
	
	if not playerDataInstance then
		print("No player data found for", player.Name)
		return
	end
	
	-- Check if map is unlocked
	if not PlayerData.isMapUnlocked(playerDataInstance, mapIndex) then
		print("Map", mapIndex, "is not unlocked for", player.Name)
		return
	end
	
	-- Get map data
	local mapData = GameConfig.MAPS[mapIndex]
	if not mapData then
		print("Invalid map index:", mapIndex)
		return
	end
	
	print("Starting game for", player.Name, "on map:", mapData.name)
	
	-- Create game session
	local gameId = userId .. "_" .. tick()
	local gameSession = {
		id = gameId,
		player = player,
		mapData = mapData,
		startTime = tick(),
		coinsCollected = 0,
		checkpointsReached = 0,
		gravityShifts = 0,
		isActive = true
	}
	
	gameState.activeGames[gameId] = gameSession
	gameState.playerSessions[userId] = {
		activeGame = gameId,
		playerData = playerDataInstance
	}
	
	-- Update statistics
	playerDataInstance.statistics.mapsPlayed = playerDataInstance.statistics.mapsPlayed + 1
	
	-- Send game data to client
	StartGame:FireClient(player, mapIndex, gameId)
	print("Game started for", player.Name, "with game ID:", gameId)
end)

-- Handle game end
EndGame.OnServerEvent:Connect(function(player, gameId, completionData)
	local userId = player.UserId
	local gameSession = gameState.activeGames[gameId]
	local playerDataInstance = playerData[userId]
	
	if not gameSession or not playerDataInstance then
		return
	end
	
	-- Calculate rewards
	local timeBonus = math.max(0, 100 - completionData.time) * 10
	local coinBonus = completionData.coins * GameConfig.COIN_VALUE
	local totalReward = timeBonus + coinBonus
	
	-- Add coins and experience
	local coinsEarned, levelBonus = PlayerData.addCoins(playerDataInstance, totalReward)
	local leveledUp, newLevel = PlayerData.addExperience(playerDataInstance, completionData.time * 10)
	
	-- Update best time if better
	local newRecord = PlayerData.updateBestTime(playerDataInstance, gameSession.mapData.name, completionData.time)
	
	-- Update statistics
	playerDataInstance.statistics.totalPlayTime = playerDataInstance.statistics.totalPlayTime + completionData.time
	playerDataInstance.statistics.coinsCollected = playerDataInstance.statistics.coinsCollected + completionData.coins
	playerDataInstance.statistics.gravityShifts = playerDataInstance.statistics.gravityShifts + completionData.gravityShifts
	
	-- Mark map as completed
	playerDataInstance.mapsCompleted[gameSession.mapData.name] = true
	
	-- Clean up game session
	gameState.activeGames[gameId] = nil
	gameState.playerSessions[userId].activeGame = nil
	
	-- Send results to client
	EndGame:FireClient(player, {
		coinsEarned = coinsEarned,
		levelBonus = levelBonus,
		timeBonus = timeBonus,
		coinBonus = coinBonus,
		totalReward = totalReward,
		leveledUp = leveledUp,
		newLevel = newLevel,
		newRecord = newRecord,
		completionTime = completionData.time
	})
	
	-- Update client with new data
	UpdatePlayerData:FireClient(player, playerDataInstance)
end)

-- Handle coin collection
CollectCoin.OnServerEvent:Connect(function(player, gameId, coinId)
	local userId = player.UserId
	local gameSession = gameState.activeGames[gameId]
	
	if not gameSession or not gameSession.isActive then
		return
	end
	
	-- Find and remove coin
	for i, coin in ipairs(gameSession.mapData.coins) do
		if coin.id == coinId and not coin.collected then
			coin.collected = true
			gameSession.coinsCollected = gameSession.coinsCollected + coin.value
			break
		end
	end
end)

-- Handle gravity updates
UpdateGravity.OnServerEvent:Connect(function(player, gameId)
	local userId = player.UserId
	local gameSession = gameState.activeGames[gameId]
	
	if not gameSession or not gameSession.isActive then
		return
	end
	
	gameSession.gravityShifts = gameSession.gravityShifts + 1
end)

-- Handle item purchases
PurchaseItem.OnServerEvent:Connect(function(player, itemId)
	local userId = player.UserId
	local playerDataInstance = playerData[userId]
	
	if not playerDataInstance then
		return
	end
	
	-- Find item in shop
	local item = nil
	for _, shopItem in ipairs(GameConfig.SHOP_ITEMS) do
		if shopItem.id == itemId then
			item = shopItem
			break
		end
	end
	
	if not item then
		return
	end
	
	-- Check if player can afford
	if not PlayerData.canAfford(playerDataInstance, item.price, item.currency) then
		return
	end
	
	-- Process purchase
	if PlayerData.purchaseItem(playerDataInstance, item.price, item.currency) then
		-- Apply item effects
		if item.type == "powerup" then
			PlayerData.upgradePowerup(playerDataInstance, itemId)
		elseif item.type == "cosmetic" then
			playerDataInstance.cosmetics[itemId] = true
		end
		
		-- Update client
		UpdatePlayerData:FireClient(player, playerDataInstance)
	end
end)

-- Auto-save player data periodically
spawn(function()
	while true do
		wait(60) -- Save every minute
		for _, player in ipairs(Players:GetPlayers()) do
			savePlayerData(player)
		end
	end
end)

-- Get player data (for other scripts)
function GameManager.getPlayerData(player)
	return playerData[player.UserId]
end

-- Get active game session
function GameManager.getActiveGame(player)
	local userId = player.UserId
	local session = gameState.playerSessions[userId]
	if session and session.activeGame then
		return gameState.activeGames[session.activeGame]
	end
	return nil
end

return GameManager ]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="10">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="11">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="12">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="13">
        <Properties>
          <string name="Name">Client</string>
          <string name="Source">local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for the Shared folder to be created by Rojo
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return
end

-- Wait for GameController to be available in the Client folder
local player = Players.LocalPlayer
print("Local player found:", player.Name)

local PlayerScripts = player:WaitForChild("PlayerScripts", 10)
if not PlayerScripts then
	warn("PlayerScripts not found")
	return
end
print("PlayerScripts found")

local ClientFolder = PlayerScripts:WaitForChild("Client", 10)
if not ClientFolder then
	warn("Client folder not found in PlayerScripts")
	return
end
print("Client folder found")

local GameControllerModule = ClientFolder:WaitForChild("GameController", 10)
if not GameControllerModule then
	warn("GameController module not found in Client folder")
	return
end
print("GameController module found")

local GameController = require(GameControllerModule)

-- Check if GameController loaded successfully
if not GameController then
	warn("Failed to load GameController")
	return
end
print("GameController loaded successfully")

-- Wait for character to load
local character = player.Character or player.CharacterAdded:Wait()

-- Initialize game when character is ready
character:WaitForChild("Humanoid")
character:WaitForChild("HumanoidRootPart")

-- Initialize the game
local success, err = pcall(GameController.init)
if not success then
	warn("Failed to initialize GameController:", err)
	return
end

-- Handle character respawning
player.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	character:WaitForChild("Humanoid")
	character:WaitForChild("HumanoidRootPart")
	
	-- Re-initialize game controller for new character
	local success, err = pcall(GameController.init)
	if not success then
		warn("Failed to re-initialize GameController:", err)
	end
end)

print("Gravity Shift - Client initialized!")</string>
        </Properties>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">GameController</string>
            <string name="Source"><![CDATA[local GameController = {}

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Wait for shared modules to be available
local Shared = ReplicatedStorage:WaitForChild("Shared", 10)
if not Shared then
	warn("Shared folder not found in ReplicatedStorage")
	return GameController
end

local GameConfig = nil
local PlayerData = nil
local UISystem = nil

-- Load shared modules with error handling
local success1, result1 = pcall(require, Shared:WaitForChild("GameConfig", 10))
if success1 then
	GameConfig = result1
else
	warn("Failed to load GameConfig:", result1)
	return GameController
end

local success2, result2 = pcall(require, Shared:WaitForChild("PlayerData", 10))
if success2 then
	PlayerData = result2
else
	warn("Failed to load PlayerData:", result2)
	return GameController
end

local success3, result3 = pcall(require, Shared:WaitForChild("UISystem", 10))
if success3 then
	UISystem = result3
else
	warn("Failed to load UISystem:", result3)
	return GameController
end

local player = Players.LocalPlayer
local character = nil
local humanoid = nil
local rootPart = nil

-- Function to setup character references
local function setupCharacterReferences()
	character = player.Character or player.CharacterAdded:Wait()
	humanoid = character:WaitForChild("Humanoid")
	rootPart = character:WaitForChild("HumanoidRootPart")
end

-- Game state (define early to prevent nil access)
local gameState = {
	isInGame = false,
	currentMap = nil,
	gameId = nil,
	startTime = 0,
	coinsCollected = 0,
	checkpointsReached = 0,
	gravityShifts = 0,
	currentGravity = Vector3.new(0, -196.2, 0), -- Default gravity, will be updated after GameConfig loads
	lastGravityChange = 0,
	canChangeGravity = true,
	activePowerups = {},
	gameObjects = {
		platforms = {},
		coins = {},
		checkpoints = {},
		obstacles = {}
	}
}

-- Update gravity with loaded config
if GameConfig then
	gameState.currentGravity = Vector3.new(0, -GameConfig.GRAVITY_SPEED, 0)
end

-- Remote events
print("Setting up remote events...")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
if not RemoteEvents then
	warn("RemoteEvents folder not found in ReplicatedStorage")
	return GameController
end
print("RemoteEvents folder found")

local RequestPlayerData = RemoteEvents:WaitForChild("RequestPlayerData", 10)
local UpdatePlayerData = RemoteEvents:WaitForChild("UpdatePlayerData", 10)
local StartGame = RemoteEvents:WaitForChild("StartGame", 10)
local EndGame = RemoteEvents:WaitForChild("EndGame", 10)
local PurchaseItem = RemoteEvents:WaitForChild("PurchaseItem", 10)
local CollectCoin = RemoteEvents:WaitForChild("CollectCoin", 10)
local UpdateGravity = RemoteEvents:WaitForChild("UpdateGravity", 10)

-- Check if all remote events loaded successfully
if not (RequestPlayerData and UpdatePlayerData and StartGame and EndGame and PurchaseItem and CollectCoin and UpdateGravity) then
	warn("Failed to load all remote events")
	print("RequestPlayerData:", RequestPlayerData ~= nil)
	print("UpdatePlayerData:", UpdatePlayerData ~= nil)
	print("StartGame:", StartGame ~= nil)
	print("EndGame:", EndGame ~= nil)
	print("PurchaseItem:", PurchaseItem ~= nil)
	print("CollectCoin:", CollectCoin ~= nil)
	print("UpdateGravity:", UpdateGravity ~= nil)
	return GameController
end
print("All remote events loaded successfully")



-- UI references
local lobbyUI = nil
local shopUI = nil
local gameHUD = nil
local pauseMenu = nil

-- Initialize game
function GameController.init()
	print("Initializing GameController...")
	
	-- Setup character references first
	setupCharacterReferences()
	
	-- Create UI
	print("Creating UI...")
	lobbyUI = UISystem.createLobbyUI()
	shopUI = UISystem.createShopUI()
	gameHUD = UISystem.createGameHUD()
	pauseMenu = UISystem.createPauseMenu()
	
	-- Request initial player data
	print("Requesting player data...")
	RequestPlayerData:FireServer()
	
	-- Setup UI connections
	print("Setting up UI connections...")
	setupUIConnections()
	
	-- Setup input handling
	print("Setting up input handling...")
	setupInputHandling()
	
	-- Setup remote event connections
	print("Setting up remote connections...")
	setupRemoteConnections()
	
	-- Show lobby
	print("Showing lobby...")
	showLobby()
	
	-- Add a simple test button to see if UI is working
	local testButton = Instance.new("TextButton")
	testButton.Size = UDim2.new(0, 200, 0, 50)
	testButton.Position = UDim2.new(0.5, -100, 0.9, 0)
	testButton.Text = "TEST BUTTON"
	testButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
	testButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	testButton.Font = Enum.Font.GothamBold
	testButton.TextScaled = true
	testButton.Parent = lobbyUI.screenGui
	
	testButton.MouseButton1Click:Connect(function()
		print("TEST BUTTON CLICKED!")
		-- Try to start the game directly
		StartGame:FireServer(1)
	end)
	
	print("GameController initialization complete!")
end

-- Setup UI connections
function setupUIConnections()
	-- Lobby UI
	lobbyUI.shopButton.MouseButton1Click:Connect(function()
		showShop()
	end)
	
	lobbyUI.settingsButton.MouseButton1Click:Connect(function()
		-- TODO: Implement settings
		print("Settings not implemented yet")
	end)
	
	-- Connect the main PLAY button to start the first available map
	print("Setting up play button connection...")
	if lobbyUI and lobbyUI.playButton then
		print("Play button found, connecting click event...")
		
		-- Add a simple test to see if the button is working
		lobbyUI.playButton.MouseButton1Click:Connect(function()
			print("Play button clicked!")
			print("Button position:", lobbyUI.playButton.Position)
			print("Button size:", lobbyUI.playButton.Size)
			print("Button visible:", lobbyUI.playButton.Visible)
			print("Button enabled:", lobbyUI.playButton.Enabled)
			
			-- Find the first unlocked map
			for i, mapData in ipairs(GameConfig.MAPS) do
				if mapData.unlocked then
					print("Starting map:", i, mapData.name)
					StartGame:FireServer(i)
					break
				end
			end
		end)
		
		-- Also add a simple test with a different event
		lobbyUI.playButton.Activated:Connect(function()
			print("Play button activated!")
		end)
		
		print("Play button connection established")
	else
		warn("Play button not found in lobbyUI")
		if lobbyUI then
			print("Available lobbyUI properties:")
			for key, value in pairs(lobbyUI) do
				print("  " .. key .. ":", value)
			end
		end
	end
	
	-- Shop UI
	shopUI.closeButton.MouseButton1Click:Connect(function()
		hideShop()
	end)
	
	-- Game HUD
	gameHUD.pauseButton.MouseButton1Click:Connect(function()
		showPauseMenu()
	end)
	
	-- Pause Menu
	pauseMenu.resumeButton.MouseButton1Click:Connect(function()
		hidePauseMenu()
	end)
	
	pauseMenu.restartButton.MouseButton1Click:Connect(function()
		restartGame()
	end)
	
	pauseMenu.quitButton.MouseButton1Click:Connect(function()
		quitToLobby()
	end)
end

-- Setup input handling
function setupInputHandling()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if gameState.isInGame then
			if input.KeyCode == Enum.KeyCode.Space then
				changeGravity()
			elseif input.KeyCode == Enum.KeyCode.R then
				restartGame()
			elseif input.KeyCode == Enum.KeyCode.Escape then
				showPauseMenu()
			end
		end
	end)
end

-- Setup remote event connections
function setupRemoteConnections()
	UpdatePlayerData.OnClientEvent:Connect(function(playerData)
		updatePlayerUI(playerData)
	end)
	
	StartGame.OnClientEvent:Connect(function(mapData, gameId)
		startGame(mapData, gameId)
	end)
	
	EndGame.OnClientEvent:Connect(function(results)
		endGame(results)
	end)
end

-- Show lobby
function showLobby()
	print("showLobby() called")
	gameState.isInGame = false
	
	-- Hide other UI
	shopUI.screenGui.Enabled = false
	gameHUD.screenGui.Enabled = false
	pauseMenu.screenGui.Enabled = false
	
	-- Show lobby
	lobbyUI.screenGui.Enabled = true
	print("Lobby UI enabled:", lobbyUI.screenGui.Enabled)
	
	-- Populate map selection
	populateMapSelection()
	
	-- Reset character
	resetCharacter()
	print("showLobby() completed")
end

-- Show shop
function showShop()
	shopUI.screenGui.Enabled = true
	populateShop()
end

-- Hide shop
function hideShop()
	shopUI.screenGui.Enabled = false
end

-- Show pause menu
function showPauseMenu()
	pauseMenu.screenGui.Enabled = true
	RunService:SetRobloxGuiFocused(false)
end

-- Hide pause menu
function hidePauseMenu()
	pauseMenu.screenGui.Enabled = false
	RunService:SetRobloxGuiFocused(true)
end

-- Populate map selection
function populateMapSelection()
	print("populateMapSelection() called")
	
	-- Clear existing items
	for _, child in ipairs(lobbyUI.mapScroller:GetChildren()) do
		child:Destroy()
	end
	
	print("Creating", #GameConfig.MAPS, "map items")
	
	-- Add map items
	for i, mapData in ipairs(GameConfig.MAPS) do
		print("Creating map item", i, ":", mapData.name)
		local mapItem = UISystem.createMapItem(lobbyUI.mapScroller, mapData, mapData.unlocked)
		
		-- Set proper position for the map item
		mapItem.frame.Position = UDim2.new(0, 0, 0, (i - 1) * 90)
		
		mapItem.button.MouseButton1Click:Connect(function()
			print("Map button clicked:", mapData.name)
			if mapData.unlocked then
				StartGame:FireServer(i)
			end
		end)
		
		-- Update canvas size
		lobbyUI.mapScroller.CanvasSize = UDim2.new(0, 0, 0, #GameConfig.MAPS * 90)
	end
	
	print("populateMapSelection() completed")
end

-- Populate shop
function populateShop()
	-- Clear existing items
	for _, child in ipairs(shopUI.itemScroller:GetChildren()) do
		child:Destroy()
	end
	
	-- Add shop items
	for i, itemData in ipairs(GameConfig.SHOP_ITEMS) do
		local shopItem = UISystem.createShopItem(shopUI.itemScroller, itemData)
		
		-- Set proper position for the shop item
		shopItem.frame.Position = UDim2.new(0, 0, 0, (i - 1) * 110)
		
		shopItem.button.MouseButton1Click:Connect(function()
			PurchaseItem:FireServer(itemData.id)
		end)
		
		-- Update canvas size
		shopUI.itemScroller.CanvasSize = UDim2.new(0, 0, 0, #GameConfig.SHOP_ITEMS * 110)
	end
end

-- Update player UI
function updatePlayerUI(playerData)
	if not playerData then return end
	
	lobbyUI.playerName.Text = playerData.name or "Player"
	lobbyUI.playerLevel.Text = "Level: " .. playerData.level
	lobbyUI.playerCoins.Text = "Coins: " .. playerData.coins
	lobbyUI.playerRobux.Text = "Robux: " .. playerData.robux
	
	-- Update map unlock status
	for i, mapData in ipairs(GameConfig.MAPS) do
		mapData.unlocked = PlayerData.isMapUnlocked(playerData, i)
	end
end

-- Start game
function startGame(mapIndex, gameId)
	-- Get the actual map data from the index
	local mapData = GameConfig.MAPS[mapIndex]
	if not mapData then
		warn("Invalid map index:", mapIndex)
		return
	end
	
	gameState.isInGame = true
	gameState.currentMap = mapData
	gameState.gameId = gameId
	gameState.startTime = tick()
	gameState.coinsCollected = 0
	gameState.checkpointsReached = 0
	gameState.gravityShifts = 0
	
	-- Hide lobby and show game HUD
	lobbyUI.screenGui.Enabled = false
	gameHUD.screenGui.Enabled = true
	
	-- Build map
	buildMap(mapData)
	
	-- Setup character
	setupCharacter()
	
	-- Start game loop
	startGameLoop()
end

-- Build map
function buildMap(mapData)
	-- Clear existing objects
	clearGameObjects()
	
	-- Create platforms
	for i, platformData in ipairs(mapData.platforms) do
		local platform = Instance.new("Part")
		platform.Name = "Platform_" .. i
		platform.Position = platformData.position
		platform.Size = platformData.size
		platform.Color = platformData.color
		platform.Anchored = true
		platform.CanCollide = true
		platform.Material = Enum.Material.Plastic
		platform.Parent = Workspace
		
		table.insert(gameState.gameObjects.platforms, platform)
		
		-- Add platform behavior
		if platformData.type == "moving" and platformData.speed then
			setupMovingPlatform(platform, platformData.speed)
		elseif platformData.type == "breakable" then
			setupBreakablePlatform(platform)
		elseif platformData.type == "bounce" then
			setupBouncePlatform(platform, platformData.bouncePower or 50)
		end
	end
	
	-- Create coins
	for i, coinData in ipairs(mapData.coins) do
		local coin = Instance.new("Part")
		coin.Name = "Coin_" .. i
		coin.Position = coinData.position
		coin.Size = Vector3.new(2, 2, 2)
		coin.Color = Color3.fromRGB(255, 215, 0) -- Gold
		coin.Anchored = true
		coin.CanCollide = false
		coin.Shape = Enum.PartType.Ball
		coin.Material = Enum.Material.Neon
		coin.Parent = Workspace
		
		-- Add spinning animation
		local bodyGyro = Instance.new("BodyGyro")
		bodyGyro.MaxTorque = Vector3.new(0, 0, 0)
		bodyGyro.D = 0
		bodyGyro.P = 0
		bodyGyro.CFrame = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		bodyGyro.Parent = coin
		
		-- Add collection detection
		local touchInterest = Instance.new("TouchTransmitter")
		touchInterest.Parent = coin
		
		coin.Touched:Connect(function(hit)
			if character and hit.Parent == character then
				collectCoin(coin, i)
			end
		end)
		
		coinData.id = i
		table.insert(gameState.gameObjects.coins, coin)
	end
	
	-- Create checkpoints
	for i, checkpointData in ipairs(mapData.checkpoints) do
		local checkpoint = Instance.new("Part")
		checkpoint.Name = "Checkpoint_" .. i
		checkpoint.Position = checkpointData.position
		checkpoint.Size = Vector3.new(4, 8, 4)
		checkpoint.Color = Color3.fromRGB(46, 204, 113) -- Green
		checkpoint.Anchored = true
		checkpoint.CanCollide = false
		checkpoint.Transparency = 0.5
		checkpoint.Material = Enum.Material.Neon
		checkpoint.Parent = Workspace
		
		-- Add checkpoint detection
		checkpoint.Touched:Connect(function(hit)
			if character and hit.Parent == character then
				reachCheckpoint(i)
			end
		end)
		
		table.insert(gameState.gameObjects.checkpoints, checkpoint)
	end
	
	-- Create obstacles
	for i, obstacleData in ipairs(mapData.obstacles) do
		local obstacle = Instance.new("Part")
		obstacle.Name = "Obstacle_" .. i
		obstacle.Position = obstacleData.position
		obstacle.Size = obstacleData.size
		obstacle.Color = obstacleData.color
		obstacle.Anchored = true
		obstacle.CanCollide = true
		obstacle.Material = Enum.Material.Neon
		obstacle.Parent = Workspace
		
		table.insert(gameState.gameObjects.obstacles, obstacle)
	end
	
	-- Create finish point
	local finish = Instance.new("Part")
	finish.Name = "Finish"
	finish.Position = mapData.finishPoint
	finish.Size = Vector3.new(10, 2, 10)
	finish.Color = Color3.fromRGB(155, 89, 182) -- Purple
	finish.Anchored = true
	finish.CanCollide = true
	finish.Material = Enum.Material.Neon
	finish.Parent = Workspace
	
	finish.Touched:Connect(function(hit)
		if character and hit.Parent == character then
			completeGame()
		end
	end)
end

-- Clear game objects
function clearGameObjects()
	for _, objects in pairs(gameState.gameObjects) do
		for _, obj in ipairs(objects) do
			if obj and obj.Parent then
				obj:Destroy()
			end
		end
		objects = {}
	end
end

-- Setup character
function setupCharacter()
	if not character or not humanoid or not rootPart then
		setupCharacterReferences()
	end
	
	if character and humanoid and rootPart then
		-- Reset character position
		character:PivotTo(CFrame.new(gameState.currentMap.spawnPoint))
		
		-- Reset humanoid properties
		humanoid.WalkSpeed = GameConfig.PLAYER_WALK_SPEED
		humanoid.JumpPower = GameConfig.PLAYER_JUMP_POWER
		humanoid.MaxSlopeAngle = GameConfig.PLAYER_MAX_SLOPE_ANGLE
		
		-- Reset gravity
		gameState.currentGravity = Vector3.new(0, -GameConfig.GRAVITY_SPEED, 0)
		gameState.canChangeGravity = true
		gameState.lastGravityChange = 0
		
		-- Update gravity indicator
		updateGravityIndicator()
	end
end

-- Change gravity
function changeGravity()
	if not gameState.canChangeGravity then return end
	
	local currentTime = tick()
	if currentTime - gameState.lastGravityChange < GameConfig.GRAVITY_CHANGE_COOLDOWN then
		return
	end
	
	-- Cycle through gravity directions
	local gravityDirections = {
		Vector3.new(0, -GameConfig.GRAVITY_SPEED, 0),  -- Down
		Vector3.new(0, GameConfig.GRAVITY_SPEED, 0),   -- Up
		Vector3.new(-GameConfig.GRAVITY_SPEED, 0, 0),  -- Left
		Vector3.new(GameConfig.GRAVITY_SPEED, 0, 0),   -- Right
		Vector3.new(0, 0, -GameConfig.GRAVITY_SPEED),  -- Forward
		Vector3.new(0, 0, GameConfig.GRAVITY_SPEED)    -- Back
	}
	
	local currentIndex = 1
	for i, direction in ipairs(gravityDirections) do
		if direction == gameState.currentGravity then
			currentIndex = i
			break
		end
	end
	
	local nextIndex = (currentIndex % #gravityDirections) + 1
	gameState.currentGravity = gravityDirections[nextIndex]
	
	-- Update physics
	Workspace.Gravity = gameState.currentGravity.Y
	
	-- Update character orientation
	if rootPart then
		local lookDirection = gameState.currentGravity.Unit
		rootPart.CFrame = CFrame.lookAt(rootPart.Position, rootPart.Position + lookDirection)
	end
	
	-- Update UI
	updateGravityIndicator()
	
	-- Update server
	UpdateGravity:FireServer(gameState.gameId)
	
	-- Update cooldown
	gameState.lastGravityChange = currentTime
	gameState.gravityShifts = gameState.gravityShifts + 1
end

-- Update gravity indicator
function updateGravityIndicator()
	local gravityText = gameState.currentGravity
	local symbol = "↓"
	
	if gravityText.Y > 0 then
		symbol = "↑"
	elseif gravityText.X < 0 then
		symbol = "←"
	elseif gravityText.X > 0 then
		symbol = "→"
	elseif gravityText.Z < 0 then
		symbol = "↗"
	elseif gravityText.Z > 0 then
		symbol = "↙"
	end
	
	gameHUD.gravityText.Text = symbol
end

-- Collect coin
function collectCoin(coin, coinId)
	if not coin or not coin.Parent then return end
	
	-- Remove coin
	coin:Destroy()
	
	-- Update state
	gameState.coinsCollected = gameState.coinsCollected + 10
	
	-- Update UI
	gameHUD.coinsLabel.Text = "Coins: " .. gameState.coinsCollected
	
	-- Notify server
	CollectCoin:FireServer(gameState.gameId, coinId)
	
	-- Play collection effect
	playCoinEffect(coin.Position)
end

-- Reach checkpoint
function reachCheckpoint(checkpointIndex)
	if checkpointIndex > gameState.checkpointsReached then
		gameState.checkpointsReached = checkpointIndex
		gameHUD.checkpointLabel.Text = "Checkpoint: " .. gameState.checkpointsReached .. "/" .. #gameState.currentMap.checkpoints
		
		-- Play checkpoint effect
		playCheckpointEffect()
	end
end

-- Complete game
function completeGame()
	local completionTime = tick() - gameState.startTime
	
	local completionData = {
		time = completionTime,
		coins = gameState.coinsCollected,
		gravityShifts = gameState.gravityShifts
	}
	
	EndGame:FireServer(gameState.gameId, completionData)
end

-- End game
function endGame(results)
	gameState.isInGame = false
	
	-- Hide game HUD
	gameHUD.screenGui.Enabled = false
	
	-- Show results (TODO: Create results UI)
	print("Game completed!")
	print("Time: " .. string.format("%.2f", results.completionTime) .. "s")
	print("Coins: " .. results.coinsEarned)
	print("Total Reward: " .. results.totalReward)
	
	if results.leveledUp then
		print("Level Up! New level: " .. results.newLevel)
	end
	
	if results.newRecord then
		print("New Record!")
	end
	
	-- Return to lobby after delay
	wait(3)
	showLobby()
end

-- Restart game
function restartGame()
	if gameState.isInGame then
		StartGame:FireServer(1) -- Restart current map
	end
end

-- Quit to lobby
function quitToLobby()
	gameState.isInGame = false
	clearGameObjects()
	showLobby()
end

-- Start game loop
function startGameLoop()
	spawn(function()
		while gameState.isInGame do
			-- Update time display
			local currentTime = tick() - gameState.startTime
			local minutes = math.floor(currentTime / 60)
			local seconds = math.floor(currentTime % 60)
			gameHUD.timeLabel.Text = string.format("Time: %02d:%02d", minutes, seconds)
			
			wait(0.1)
		end
	end)
end

-- Platform behaviors
function setupMovingPlatform(platform, speed)
	spawn(function()
		local startPos = platform.Position
		local direction = 1
		
		while platform and platform.Parent do
			local newPos = startPos + Vector3.new(0, math.sin(tick() * speed.Y) * 10, 0)
			platform.Position = newPos
			wait(0.01)
		end
	end)
end

function setupBreakablePlatform(platform)
	platform.Touched:Connect(function(hit)
		if character and hit.Parent == character then
			wait(0.5)
			platform:Destroy()
		end
	end)
end

function setupBouncePlatform(platform, bouncePower)
	platform.Touched:Connect(function(hit)
		if character and hit.Parent == character and humanoid then
			humanoid.JumpPower = bouncePower
			wait(0.1)
			humanoid.JumpPower = GameConfig.PLAYER_JUMP_POWER
		end
	end)
end

-- Effects
function playCoinEffect(position)
	-- TODO: Add particle effects
end

function playCheckpointEffect()
	-- TODO: Add checkpoint effects
end

-- Reset character
function resetCharacter()
	if character and character.Parent then
		character:PivotTo(CFrame.new(0, 10, 0))
	end
end

-- Update character references when character respawns
player.CharacterAdded:Connect(function(newCharacter)
	setupCharacterReferences()
end)

return GameController ]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="15">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
    <Item class="Part" referent="16">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <Color3uint8 name="Color3uint8">6512483</Color3uint8>
        <bool name="Locked">true</bool>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-10</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>512</X>
          <Y>20</Y>
          <Z>512</Z>
        </Vector3>
      </Properties>
    </Item>
  </Item>
</roblox>